{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This website contains reference material for developers working with Saxo's OpenAPI. Saxo's OpenAPI (henceforth referred to as the OpenAPI or simply API ) is the gateway to Saxo's trading infrastructure, and is available for individual clients, institutional partners, and third parties. The aim of this guide is to make it as easy as possible for developers of any kind to interact successfully with the OpenAPI. Because of the inherent complexities of a financial-services API and the broad range of use-cases and client types it supports, the learning material on this website is broken down into 4 distinct sections: The Basics - This collection of articles covers high-level fundamental concepts of the OpenAPI that programmers of any kind are expected to understand and be able implement. You can safely assume that (the majority of) the ideas explained in this section will apply to your use-case. This section is divided in two threads: Core Business Concepts , which includes articles on the basic ideas behind the API and the mechanics that are at play, such as: [add examples here] Fundamental Programming Concepts , which provide guidance on how to build the technical foundation of your application 'the right way', covering aspects such as: [add examples here] Individual Developers - If you are a direct client of Saxo Bank (or any of its local subsidiaries), you will find additional information tailored to your use case in this section. It covers concepts such as [how do I configure my personal trading app] and [can I use certificate-based authentication?]. This section is updated with new articles for frequently-asked topics that apply to individual client developers. Institutional Developers - This section includes articles specifically for developers of Saxo Bank's partners , and focusses on topics such as client management within Saxo's hierarchy structure, signing up new clients through the CRM API, and client reporting. If you are a developer for one of Saxo's partners, you can find relevant information here. 3rd-Party App Developers - Articles in this collection apply to developers that are looking to integrate with Saxo trading functionality and (market) data on their proprietary applications , and distribute their product to Saxo clients. This section provides details on how to configure your app's interactions with the OpenAPI, ensuring the optimal 'Saxo Experience' for clients when they log into your platform. Before diving into the above articles however, click the Next button on the bottom right of this page to continue to the user manual of the documentation provided on this web site so you can ensure you leverage all the available information to its fullest extend.","title":"Welcome"},{"location":"disclaimer/","text":"MIT License Copyright (c) 2020 Saxo Bank A/S Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Disclaimer"},{"location":"support/","text":"Abstract In order for Saxo's support team to provide quality development support, we need your help to perform debugging and provide us with as much information as you can. As mentioned on the welcome page , Saxo's OpenAPI is a complex piece of machinery. The support team is available to provide assistance whenever required, however do bear in mind that providing proper support relies in large part on the information provided by you . It is recommended to follow the below steps to analyze the issue you are facing. Step 1: Basic Diagnosis \u00b6 Although it is of course possible that the difficulties you are facing are caused by the OpenAPI, requests are often received from developers that are digging into tracebacks originating from a flaw in their application, rather than an issue with the OpenAPI. If you think the OpenAPI is the source of the problem, please verify your suspicion by answering the below 3 questions: Analyze the traceback (or logs) provided by your development environment. Does it indicate that all processes are working fine within the app and the issue is in fact caused when a request is sent to (or received from) the OpenAPI? Extract the request at point of failure: pluck the the misbehaving HTTP request out of context including its headers, parameters, body, and cookies. You can use a debugging proxy like Fiddler to simplify this process. Does the request conform to basic OpenAPI HTTP request requirements? Verify the request using an API debugging tool such as Postman , or directly from the command line using curl . Does this result in the same response/error/behavior? Step 2: Use the Search & Check the FAQ \u00b6 The search tool at the top of this window is a quick and powerful way to scan every bit of information on this website. Make sure to use different combinations of keywords if you are not able to find the information you are looking for and check the FAQ to see if your specific question has come up before. FAQ articles are added progressively for every question received by OpenAPI support. Step 3: Email OpenAPI Support \u00b6 If all of the above did not help you find an answer, the support team would be glad to receive a message on openapisupport@saxobank.com . Please bear in mind you can help us help you by including as many details as possible in your inquiry. The OpenAPI receives millions of requests every day, so it is virtually impossible to even begin to provide support if all we have is an email address and a message such as \"it doesn't work\". Here's how to request support like a pro : Include a clear description of the issue/bug/problem/obstacle that you are facing along the lines of: \"I am trying to achieve business requirement so I sent a request to the OpenAPI such as this request example and I expected to receive desired outcome but instead I got unexpected behavior .\" Add the details of the request that results in the error. If you followed Step 1 , you will have this at hand already. Make sure to include: The URL (including parameters), request method, and (if applicable) the request body Any headers or cookies that are sent with the request The timestamp of the request The UserId or ClientId associated with the request (if you are using a top-level client, make sure to include both the top-level ID and the target client ID) And finally, add the details of the response : The response code and body The timestamp of the response Most importantly : the X-Correlation header Tip The X-Correlation header is an internal Saxo identifier which we can track throughout our systems. Make sure to send us this value! About the X-Correlation Header \u00b6 Imagine you are about to send a support request and you can only include 1 piece of information , what should it be? Answer: the X-Correlation header. The OpenAPI sends out correlation headers with every response , which encode important contextual details regarding your requests and allows for direct log queries . It goes without saying that this is by far the most useful info our team could receive from you! If you've tried the request demonstrated in the code block on one of the earlier pages , you may have noticed that the X-Correlation header was indeed included in the response headers from the OpenAPI, as shown in the below HTTP response: HTTP / 1.1 200 OK Date : Wed, 05 Feb 2020 17:51:52 GMT Content-Length : 0 Cache-Control : no-cache Pragma : no-cache Expires : -1 X-Correlation : ##6a6f4979-f2b9-4d54-9712-9cf505e3bdc9#82","title":"Requesting Support"},{"location":"support/#step-1-basic-diagnosis","text":"Although it is of course possible that the difficulties you are facing are caused by the OpenAPI, requests are often received from developers that are digging into tracebacks originating from a flaw in their application, rather than an issue with the OpenAPI. If you think the OpenAPI is the source of the problem, please verify your suspicion by answering the below 3 questions: Analyze the traceback (or logs) provided by your development environment. Does it indicate that all processes are working fine within the app and the issue is in fact caused when a request is sent to (or received from) the OpenAPI? Extract the request at point of failure: pluck the the misbehaving HTTP request out of context including its headers, parameters, body, and cookies. You can use a debugging proxy like Fiddler to simplify this process. Does the request conform to basic OpenAPI HTTP request requirements? Verify the request using an API debugging tool such as Postman , or directly from the command line using curl . Does this result in the same response/error/behavior?","title":"Step 1: Basic Diagnosis"},{"location":"support/#step-2-use-the-search-check-the-faq","text":"The search tool at the top of this window is a quick and powerful way to scan every bit of information on this website. Make sure to use different combinations of keywords if you are not able to find the information you are looking for and check the FAQ to see if your specific question has come up before. FAQ articles are added progressively for every question received by OpenAPI support.","title":"Step 2: Use the Search &amp; Check the FAQ"},{"location":"support/#step-3-email-openapi-support","text":"If all of the above did not help you find an answer, the support team would be glad to receive a message on openapisupport@saxobank.com . Please bear in mind you can help us help you by including as many details as possible in your inquiry. The OpenAPI receives millions of requests every day, so it is virtually impossible to even begin to provide support if all we have is an email address and a message such as \"it doesn't work\". Here's how to request support like a pro : Include a clear description of the issue/bug/problem/obstacle that you are facing along the lines of: \"I am trying to achieve business requirement so I sent a request to the OpenAPI such as this request example and I expected to receive desired outcome but instead I got unexpected behavior .\" Add the details of the request that results in the error. If you followed Step 1 , you will have this at hand already. Make sure to include: The URL (including parameters), request method, and (if applicable) the request body Any headers or cookies that are sent with the request The timestamp of the request The UserId or ClientId associated with the request (if you are using a top-level client, make sure to include both the top-level ID and the target client ID) And finally, add the details of the response : The response code and body The timestamp of the response Most importantly : the X-Correlation header Tip The X-Correlation header is an internal Saxo identifier which we can track throughout our systems. Make sure to send us this value!","title":"Step 3: Email OpenAPI Support"},{"location":"support/#about-the-x-correlation-header","text":"Imagine you are about to send a support request and you can only include 1 piece of information , what should it be? Answer: the X-Correlation header. The OpenAPI sends out correlation headers with every response , which encode important contextual details regarding your requests and allows for direct log queries . It goes without saying that this is by far the most useful info our team could receive from you! If you've tried the request demonstrated in the code block on one of the earlier pages , you may have noticed that the X-Correlation header was indeed included in the response headers from the OpenAPI, as shown in the below HTTP response: HTTP / 1.1 200 OK Date : Wed, 05 Feb 2020 17:51:52 GMT Content-Length : 0 Cache-Control : no-cache Pragma : no-cache Expires : -1 X-Correlation : ##6a6f4979-f2b9-4d54-9712-9cf505e3bdc9#82","title":"About the X-Correlation Header"},{"location":"tools/","text":"Abstract Developing against the OpenAPI is made easy with a selection of tools that provide useful features for anyone looking to get started quickly. Check out: The Developer Portal The Tutorial The OpenAPI Explorer 24-Hour Tokens Application Management Postman Fiddler To optimize your development efforts while working with Saxo's OpenAPI, the below tools are recommended for any developer. These tools range from 'get to know the platform'-apps to fully-fledged debugging environments. You are invited to use these tools as you progress through the articles on this website, as they provide an excellent way to try the features of the OpenAPI yourself while you learn about them. Tools Provided by Saxo \u00b6 The Developer Portal \u00b6 This is the go-to resource if you are starting out on the OpenAPI. Create a developer account on the portal to fully leverage the features it provides (see below). This account lives in Saxo's Simulation (or 'Demo') environment and is pre-configured to be used as OpenAPI user. You can log into SaxoTraderGO or SaxoTraderPRO with this account to see what a 'standard' Saxo configuration looks like. It is generally recommended to check these platforms out if you haven't seen them already - they are built entirely on top of the OpenAPI infrastructure (observing network traffic from these apps can tell you a lot about appropriate OpenAPI usage). The Tutorial \u00b6 Info The Tutorial and other Developer Portal tools discussed below require an account on the portal before they can be used. See the steps outlined above to create you free account. The Tutorial is a simple 3-minute click-through guide on the Developer Portal that showcases a couple of basic API request/response examples. It provides an excellent introduction into core aspects of the OpenAPI and is generally recommended as a good 'get to know the API'-tool. The OpenAPI Explorer \u00b6 Now that you have acquired a basic understanding of the OpenAPI, let's build some requests ourselves! The Explorer is very similar to tools such as Postman (see below) and lets you create your own requests directly on the portal. It is convenient for on-the-fly debugging and trying out certain endpoints to 'get a feel' for how they behave before implementing them into your own application. It supports all available API endpoints and includes streaming: you can set up a webSocket connection and watch updates flow in real-time. 24-Hour Tokens \u00b6 At this point, you probably want to start calling the OpenAPI from within your own application/environment. To make this easy, Saxo provides 24-hour tokens which you can hard-code into the sample you are building (practically skipping the authentication step altogether). Accept the disclaimer on the portal and get started with requests inside your own app right away! Application Management \u00b6 You can register an application in Saxo's SIM environment on the above link and obtain your own AppKey and AppSecret , which can be used to request access and refresh tokens through [Saxo's standard OAuth implementation]. This is considered the final step in your journey towards a 'real-life' app. Third-Party Tools \u00b6 The below apps can be used for free and are generally considered exceptional Web/API debugging tools. Saxo is not affiliated with any of these platforms. Postman \u00b6 An open-source API debugging app that allows the user to conveniently test any (Web) API. Very similar to the Explorer discussed above, but allows for more extensive in-depth request configuration. Great way to quickly tinker with OpenAPI requests before implementing them into your own application. Fiddler \u00b6 A comprehensive web debugging proxy that allows the user to monitor their app's behavior and catch failing API calls in real-time. Especially useful when your app starts to scale out and sends numerous requests to the OpenAPI (asynchronously). Strongly recommended in case you run into (potential) bugs or issues as it records valuable information that the Saxo team needs to provide efficient support (see next section).","title":"Useful Tools"},{"location":"tools/#tools-provided-by-saxo","text":"","title":"Tools Provided by Saxo"},{"location":"tools/#the-developer-portal","text":"This is the go-to resource if you are starting out on the OpenAPI. Create a developer account on the portal to fully leverage the features it provides (see below). This account lives in Saxo's Simulation (or 'Demo') environment and is pre-configured to be used as OpenAPI user. You can log into SaxoTraderGO or SaxoTraderPRO with this account to see what a 'standard' Saxo configuration looks like. It is generally recommended to check these platforms out if you haven't seen them already - they are built entirely on top of the OpenAPI infrastructure (observing network traffic from these apps can tell you a lot about appropriate OpenAPI usage).","title":"The Developer Portal"},{"location":"tools/#the-tutorial","text":"Info The Tutorial and other Developer Portal tools discussed below require an account on the portal before they can be used. See the steps outlined above to create you free account. The Tutorial is a simple 3-minute click-through guide on the Developer Portal that showcases a couple of basic API request/response examples. It provides an excellent introduction into core aspects of the OpenAPI and is generally recommended as a good 'get to know the API'-tool.","title":"The Tutorial"},{"location":"tools/#the-openapi-explorer","text":"Now that you have acquired a basic understanding of the OpenAPI, let's build some requests ourselves! The Explorer is very similar to tools such as Postman (see below) and lets you create your own requests directly on the portal. It is convenient for on-the-fly debugging and trying out certain endpoints to 'get a feel' for how they behave before implementing them into your own application. It supports all available API endpoints and includes streaming: you can set up a webSocket connection and watch updates flow in real-time.","title":"The OpenAPI Explorer"},{"location":"tools/#24-hour-tokens","text":"At this point, you probably want to start calling the OpenAPI from within your own application/environment. To make this easy, Saxo provides 24-hour tokens which you can hard-code into the sample you are building (practically skipping the authentication step altogether). Accept the disclaimer on the portal and get started with requests inside your own app right away!","title":"24-Hour Tokens"},{"location":"tools/#application-management","text":"You can register an application in Saxo's SIM environment on the above link and obtain your own AppKey and AppSecret , which can be used to request access and refresh tokens through [Saxo's standard OAuth implementation]. This is considered the final step in your journey towards a 'real-life' app.","title":"Application Management"},{"location":"tools/#third-party-tools","text":"The below apps can be used for free and are generally considered exceptional Web/API debugging tools. Saxo is not affiliated with any of these platforms.","title":"Third-Party Tools"},{"location":"tools/#postman","text":"An open-source API debugging app that allows the user to conveniently test any (Web) API. Very similar to the Explorer discussed above, but allows for more extensive in-depth request configuration. Great way to quickly tinker with OpenAPI requests before implementing them into your own application.","title":"Postman"},{"location":"tools/#fiddler","text":"A comprehensive web debugging proxy that allows the user to monitor their app's behavior and catch failing API calls in real-time. Especially useful when your app starts to scale out and sends numerous requests to the OpenAPI (asynchronously). Strongly recommended in case you run into (potential) bugs or issues as it records valuable information that the Saxo team needs to provide efficient support (see next section).","title":"Fiddler"},{"location":"usage/","text":"The aim of this guide is to be as readable as possible, while it at the same time provides in-depth discussions of each topic and comprehensive code samples. To keep things clean, side-topics are relegated to separate blocks in each article, and concise sample code is woven into each discussion using multi-language code blocks and line highlighting. Structure \u00b6 The individual sections in this guide are organized as much as possible in chronological order , taking you from the initial steps all the way to s fully-fledged OpenAPI integration. Although some of the articles might not directly apply to your use-case, it is recommended to start 'at the top' and click/skim through each of the provided articles using the Next navigation button in the bottom right of each page. Every article is pre-faced by an Abstract providing a succinct summary of the article's contents. Important concepts, pitfalls, or useful notes are exhibited using (collapsible) notes, info boxes, and warnings. Abstract This article explains how the OpenAPI guide is intended to be used and what features it includes, such as multi-language code blocks. This is a collapsible block containing additional information Blocks such as these provide supplementary context and are not necessarily required to be read in order to understand the concept being discussed. Take care when you see these blocks! Warning blocks like this one inform the reader that the topic under discussion might result in an adverse outcome if the reader applies the presented code or concepts incorrectly. Usage of Links \u00b6 This guide provides links to many online resources to offer as much context as possible. All links annotated by the -symbol link away from these pages and will take you to a different domain. All other links that are not annotated refer to pages on this website. Example of an external link: go to Saxo's Developer Portal Example of an internal links: visit the home page of this site Sample Code \u00b6 Where possible, concise, stand-alone code samples are provided in various programming languages to illustrate concepts under discussion with real-life code (see below). This code is meant to be testable and you are welcome to run it, but do bear in mind that it should only be used for educational purposes. Please administer proper due diligence if you are planning to use any of the provided code in production. No guarantees are offered for the correctness of the included samples (see the Disclaimer ). If required, certain lines in the code blocks will be highlighted in case they require special attention such as adding an access token, or if the line is particularly important in the context of the article. When copying sample code, please double-check the highlighted lines because it could be the reason your code won't run 'out of the box'. If you find an error in the sample code, feel free to send our support a message! The OpenAPI is a RESTful Web API based entirely on HTTP methods, so all code blocks will typically include a generic, language-agnostic HTTP sample. The below sample code demonstrates a simple request to the /root/v1/diagnostics/get endpoint, which constitutes a basic check to verify that GET requests are working fine in the client application, and the OpenAPI correctly received your request. For illustration purposes, each code sample highlights the location in the code where the Host header is defined: HTTP GET /sim/openapi/root/v1/diagnostics/get HTTP / 1.1 Host : gateway.saxobank.com Accept : */* Accept-Encoding : gzip, deflate Connection : Keep-Alive Python import requests r = request . request ( url = '/sim/openapi/root/v1/diagnostics/get' headers = { 'Host' : 'gateway.saxobank.com' 'Accept' : '*/*' 'Accept-Encoding' : 'gzip, deflate' 'Connection' : 'Keep-Alive' } ) This request results in the following HTTP 200 OK response, indicating that the diagnostics check passed successfully: HTTP / 1.1 200 OK Date : Wed, 05 Feb 2020 17:51:52 GMT Content-Length : 0 Cache-Control : no-cache Pragma : no-cache Expires : -1 X-Correlation : ##6a6f4979-f2b9-4d54-9712-9cf505e3bdc9#82","title":"Using this Guide"},{"location":"usage/#structure","text":"The individual sections in this guide are organized as much as possible in chronological order , taking you from the initial steps all the way to s fully-fledged OpenAPI integration. Although some of the articles might not directly apply to your use-case, it is recommended to start 'at the top' and click/skim through each of the provided articles using the Next navigation button in the bottom right of each page. Every article is pre-faced by an Abstract providing a succinct summary of the article's contents. Important concepts, pitfalls, or useful notes are exhibited using (collapsible) notes, info boxes, and warnings. Abstract This article explains how the OpenAPI guide is intended to be used and what features it includes, such as multi-language code blocks. This is a collapsible block containing additional information Blocks such as these provide supplementary context and are not necessarily required to be read in order to understand the concept being discussed. Take care when you see these blocks! Warning blocks like this one inform the reader that the topic under discussion might result in an adverse outcome if the reader applies the presented code or concepts incorrectly.","title":"Structure"},{"location":"usage/#usage-of-links","text":"This guide provides links to many online resources to offer as much context as possible. All links annotated by the -symbol link away from these pages and will take you to a different domain. All other links that are not annotated refer to pages on this website. Example of an external link: go to Saxo's Developer Portal Example of an internal links: visit the home page of this site","title":"Usage of Links"},{"location":"usage/#sample-code","text":"Where possible, concise, stand-alone code samples are provided in various programming languages to illustrate concepts under discussion with real-life code (see below). This code is meant to be testable and you are welcome to run it, but do bear in mind that it should only be used for educational purposes. Please administer proper due diligence if you are planning to use any of the provided code in production. No guarantees are offered for the correctness of the included samples (see the Disclaimer ). If required, certain lines in the code blocks will be highlighted in case they require special attention such as adding an access token, or if the line is particularly important in the context of the article. When copying sample code, please double-check the highlighted lines because it could be the reason your code won't run 'out of the box'. If you find an error in the sample code, feel free to send our support a message! The OpenAPI is a RESTful Web API based entirely on HTTP methods, so all code blocks will typically include a generic, language-agnostic HTTP sample. The below sample code demonstrates a simple request to the /root/v1/diagnostics/get endpoint, which constitutes a basic check to verify that GET requests are working fine in the client application, and the OpenAPI correctly received your request. For illustration purposes, each code sample highlights the location in the code where the Host header is defined: HTTP GET /sim/openapi/root/v1/diagnostics/get HTTP / 1.1 Host : gateway.saxobank.com Accept : */* Accept-Encoding : gzip, deflate Connection : Keep-Alive Python import requests r = request . request ( url = '/sim/openapi/root/v1/diagnostics/get' headers = { 'Host' : 'gateway.saxobank.com' 'Accept' : '*/*' 'Accept-Encoding' : 'gzip, deflate' 'Connection' : 'Keep-Alive' } ) This request results in the following HTTP 200 OK response, indicating that the diagnostics check passed successfully: HTTP / 1.1 200 OK Date : Wed, 05 Feb 2020 17:51:52 GMT Content-Length : 0 Cache-Control : no-cache Pragma : no-cache Expires : -1 X-Correlation : ##6a6f4979-f2b9-4d54-9712-9cf505e3bdc9#82","title":"Sample Code"},{"location":"basics/","text":"Abstract The OpenAPI is a HTTP-based RESTful API with streaming support that is built on modern web standards. OpenAPI summary \u00b6","title":"Introduction"},{"location":"basics/#openapi-summary","text":"","title":"OpenAPI summary"},{"location":"basics/core-business-concepts/","text":"Abstract A number of key concepts form the foundation of the OpenAPI. In order to use the OpenAPI effectively, basic knowledge of these concepts and the way they interact is required. In order to use the OpenAPI effectively, it is important to understand some of the core concepts that underlie the objects, interactions, and mechanisms that you will encounter. General understanding off these concepts is regarded 'common knowledge' for anyone that works with the OpenAPI. Examples are provided where possible to illustrate common use cases of these concepts. Not every concept directly applies to your case as many aspects are configurable on a client level, meaning that you might not have access to some of the subjects that are discussed. Finding Your Way Around the OpenAPI \u00b6 The OpenAPI is organized into service groups, which are collections of related services/endpoints.","title":"Overview"},{"location":"basics/core-business-concepts/#finding-your-way-around-the-openapi","text":"The OpenAPI is organized into service groups, which are collections of related services/endpoints.","title":"Finding Your Way Around the OpenAPI"},{"location":"basics/core-business-concepts/client-user-account/","text":"Abstract Three key elements make up Saxo's internal hierarchy model: the client, user, and account. These entities are at the basis of all OpenAPI endpoints and functions, and distinct business logic and rules apply to each entity differently. The OpenAPI is designed around Saxo's core client structure, and the provided functionality inherits many features from the architectural model. To understand the different aspects of the environment that contains client information and the business logic that applies on different levels across this environment, it is important to consider that Saxo's systems are organized in a hierarchical structure. This model generally applies to any client and the accounts they hold with Saxo. Aggregation always 'flows up' in this hierarchy and ultimately ends at the top level, which can be a single client or an owner of multiple clients. Three Key Entities \u00b6 Three entities make up this environment: the client , user , and account . Generally speaking, a client: has a user or multiple users that are allowed to log into this client and act on this client's behalf in varying capacities, owns one or more accounts (possibly with differing configuration) that operations can be applied to, and (optionally) owns underlying clients that it has control over, enabling hierarchical structures. The most straightforward case is that of a 'standard' direct customer, which is a single client entity owned by Saxo 1 (both are blue in the diagram below) with one authorized user (orange), which has full access to the sole account (green) that this client owns: graph LR O(\"Saxo (owner)\") -.- C(Client) U(User) -- login --> C C -- controls --> A(Account) style O fill:SkyBlue style C fill:SkyBlue style U fill:SandyBrown style A fill:LightGreen A client can have more than 1 account linked to it and more than a single user that is allowed to access the client, for instance if the client is set up as a shared/joint customer and has accounts in multiple currencies or for different instrument types: graph LR O(\"Saxo (owner)\") -.- C(Client) U(User 1: Alice <br/> User 2: Bob) --> C C --> A(Account 1: USD Forex <br/> Account 2: USD Equities <br/> Account 3: EUR <br/> Account 4: GBP) style O fill:SkyBlue style C fill:SkyBlue style U fill:SandyBrown style A fill:LightGreen A client can also own subsequent clients itself, which yields a hierarchy. The owner is known as the 'top-level client', which has privileges over the accounts of the clients below it, such as being able to view accounts and place orders. graph LR O(\"Saxo (owner)\") -.- TLC(Top-level Client) TLU(User 1: Trader <br/> User 2: Back Office) --> TLC TLC --> TLA(Top-level Account 1 <br/> Top-level Account 2) TLC --> C1(End client 1) TLC --> C2(End client 2) TLC --> C3(End client 3) C1 --> A1(Account 1) C2 --> A2(Account 2) C3 --> A3(Account 3) style O fill:SkyBlue style TLC fill:SkyBlue style C1 fill:SkyBlue style C2 fill:SkyBlue style C3 fill:SkyBlue style TLU fill:SandyBrown style TLA fill:LightGreen style A1 fill:LightGreen style A2 fill:LightGreen style A3 fill:LightGreen Info In the above schema, users linked directly to the end clients are omitted for the sake of brevity. Characteristics \u00b6 Client \u00b6 This entity is a core entity that constitutes a taxable person or organization (legal entity). It represents the default 'node' of aggregation, which is known as a 'portfolio calculation entity'. Business logic that applies on this level: The base currency is set on the client and is the main aggregation currency for all accounts owned by this client. Accounts and positions on accounts that are not in default currency are converted in real-time. Fields such as ProfitAndLossInBaseCurrency refer to the currency specified on the client level. Margin exposure is calculated and managed on the client level, taking into consideration all leveraged products in the accounts that the client owns. In some cases, margin calculation can also be tied to an individual account or a group of accounts (see below). General instrument access is controlled on this level, which affects the instruments that associated users can see and accounts can trade in. User \u00b6 This entity is an access entity with a unique username and password associated to a specific client. Normally a client has a single associated user, but in case of shared accounts or a power-of-attorney setup, a client can have multiple authorized users. Business logic that applies to the user level: Purchasable subscriptions for real-time market data are tied to individual users ( not to the associated client). Each end user subscribes to market data individually. Access to (a specific subset of) trading applications and tools is controlled by user-specific configuration. Certain read-only users might for instance only have access to tools that cannot trade. Operations that users are allowed to perform are controlled by user roles, which include operations for directly-owned accounts or accounts of clients lower in the hierarchy. Account \u00b6 A client has one or more linked accounts, which are legal entities in themselves (identified by IBAN's). Operations such as trading, funding, requesting quotes, etc. are all performed at the account level. While margin is calculated on the client level, bookings making up the margin occur on the account level and collateral and credit lines are associated to individual accounts. Business logic present on this level: Beyond normal trading accounts, a client may have specialized accounts for commissions, multi-currency settlement, DMA trading, IRAs, ISAs, AutoTrading, etc. Each account type has different sets of configuration that applies to it, and is treated differently in back office processes depending on the this configuration. Accounts may be set up for individual margin calculation, overriding the normal client-level calculation (see above). Accounts may restrict the instrument types that can be traded on them, and clients can have separate accounts associated to individual instrument types. Accounts may be configured to perform currency conversion for executed trades at end-of-day rates or at execution time rates (the latter of which is the default). Special Entities \u00b6 Account Groups \u00b6 One or more accounts can also be grouped together into an account group to manage margin exposure as a separate entity directly. This entity only exists as a portfolio calculation entity and does not represent a legal entity, as it is in fact a collection of legal entities, i.e. individual accounts. Account groups may have specific margin requirements and stop out procedures, superseding the default client-level margin calculations. Since no bookings occur on these groups directly, calculations are always performed in the client's base currency (a Euro-default client can only have account groups calculated in the Euro currency). Partner Clients \u00b6 A top-level client which has access to their own hierarchy of underlying clients is usually associated to partners of Saxo Bank such as white label partners or introducing brokers. This particular type of client has a specific setup that aggregates all the underlying clients' accounts at the top level, which allows the partner to control their aggregated margins, exposure, and other portfolio and risk management metrics. Every client is, through multitude hierarchies, eventually always owned by a Saxo entity. \u21a9","title":"The Client-User-Account Model"},{"location":"basics/core-business-concepts/client-user-account/#three-key-entities","text":"Three entities make up this environment: the client , user , and account . Generally speaking, a client: has a user or multiple users that are allowed to log into this client and act on this client's behalf in varying capacities, owns one or more accounts (possibly with differing configuration) that operations can be applied to, and (optionally) owns underlying clients that it has control over, enabling hierarchical structures. The most straightforward case is that of a 'standard' direct customer, which is a single client entity owned by Saxo 1 (both are blue in the diagram below) with one authorized user (orange), which has full access to the sole account (green) that this client owns: graph LR O(\"Saxo (owner)\") -.- C(Client) U(User) -- login --> C C -- controls --> A(Account) style O fill:SkyBlue style C fill:SkyBlue style U fill:SandyBrown style A fill:LightGreen A client can have more than 1 account linked to it and more than a single user that is allowed to access the client, for instance if the client is set up as a shared/joint customer and has accounts in multiple currencies or for different instrument types: graph LR O(\"Saxo (owner)\") -.- C(Client) U(User 1: Alice <br/> User 2: Bob) --> C C --> A(Account 1: USD Forex <br/> Account 2: USD Equities <br/> Account 3: EUR <br/> Account 4: GBP) style O fill:SkyBlue style C fill:SkyBlue style U fill:SandyBrown style A fill:LightGreen A client can also own subsequent clients itself, which yields a hierarchy. The owner is known as the 'top-level client', which has privileges over the accounts of the clients below it, such as being able to view accounts and place orders. graph LR O(\"Saxo (owner)\") -.- TLC(Top-level Client) TLU(User 1: Trader <br/> User 2: Back Office) --> TLC TLC --> TLA(Top-level Account 1 <br/> Top-level Account 2) TLC --> C1(End client 1) TLC --> C2(End client 2) TLC --> C3(End client 3) C1 --> A1(Account 1) C2 --> A2(Account 2) C3 --> A3(Account 3) style O fill:SkyBlue style TLC fill:SkyBlue style C1 fill:SkyBlue style C2 fill:SkyBlue style C3 fill:SkyBlue style TLU fill:SandyBrown style TLA fill:LightGreen style A1 fill:LightGreen style A2 fill:LightGreen style A3 fill:LightGreen Info In the above schema, users linked directly to the end clients are omitted for the sake of brevity.","title":"Three Key Entities"},{"location":"basics/core-business-concepts/client-user-account/#characteristics","text":"","title":"Characteristics"},{"location":"basics/core-business-concepts/client-user-account/#client","text":"This entity is a core entity that constitutes a taxable person or organization (legal entity). It represents the default 'node' of aggregation, which is known as a 'portfolio calculation entity'. Business logic that applies on this level: The base currency is set on the client and is the main aggregation currency for all accounts owned by this client. Accounts and positions on accounts that are not in default currency are converted in real-time. Fields such as ProfitAndLossInBaseCurrency refer to the currency specified on the client level. Margin exposure is calculated and managed on the client level, taking into consideration all leveraged products in the accounts that the client owns. In some cases, margin calculation can also be tied to an individual account or a group of accounts (see below). General instrument access is controlled on this level, which affects the instruments that associated users can see and accounts can trade in.","title":"Client"},{"location":"basics/core-business-concepts/client-user-account/#user","text":"This entity is an access entity with a unique username and password associated to a specific client. Normally a client has a single associated user, but in case of shared accounts or a power-of-attorney setup, a client can have multiple authorized users. Business logic that applies to the user level: Purchasable subscriptions for real-time market data are tied to individual users ( not to the associated client). Each end user subscribes to market data individually. Access to (a specific subset of) trading applications and tools is controlled by user-specific configuration. Certain read-only users might for instance only have access to tools that cannot trade. Operations that users are allowed to perform are controlled by user roles, which include operations for directly-owned accounts or accounts of clients lower in the hierarchy.","title":"User"},{"location":"basics/core-business-concepts/client-user-account/#account","text":"A client has one or more linked accounts, which are legal entities in themselves (identified by IBAN's). Operations such as trading, funding, requesting quotes, etc. are all performed at the account level. While margin is calculated on the client level, bookings making up the margin occur on the account level and collateral and credit lines are associated to individual accounts. Business logic present on this level: Beyond normal trading accounts, a client may have specialized accounts for commissions, multi-currency settlement, DMA trading, IRAs, ISAs, AutoTrading, etc. Each account type has different sets of configuration that applies to it, and is treated differently in back office processes depending on the this configuration. Accounts may be set up for individual margin calculation, overriding the normal client-level calculation (see above). Accounts may restrict the instrument types that can be traded on them, and clients can have separate accounts associated to individual instrument types. Accounts may be configured to perform currency conversion for executed trades at end-of-day rates or at execution time rates (the latter of which is the default).","title":"Account"},{"location":"basics/core-business-concepts/client-user-account/#special-entities","text":"","title":"Special Entities"},{"location":"basics/core-business-concepts/client-user-account/#account-groups","text":"One or more accounts can also be grouped together into an account group to manage margin exposure as a separate entity directly. This entity only exists as a portfolio calculation entity and does not represent a legal entity, as it is in fact a collection of legal entities, i.e. individual accounts. Account groups may have specific margin requirements and stop out procedures, superseding the default client-level margin calculations. Since no bookings occur on these groups directly, calculations are always performed in the client's base currency (a Euro-default client can only have account groups calculated in the Euro currency).","title":"Account Groups"},{"location":"basics/core-business-concepts/client-user-account/#partner-clients","text":"A top-level client which has access to their own hierarchy of underlying clients is usually associated to partners of Saxo Bank such as white label partners or introducing brokers. This particular type of client has a specific setup that aggregates all the underlying clients' accounts at the top level, which allows the partner to control their aggregated margins, exposure, and other portfolio and risk management metrics. Every client is, through multitude hierarchies, eventually always owned by a Saxo entity. \u21a9","title":"Partner Clients"},{"location":"basics/core-business-concepts/retrieving-entity-data/","text":"Abstract Almost all OpenAPI endpoints depend on configuration settings that can be retrieved for each of the entities discussed in the previous article . It is therefore important to understand how and where configuration can be retrieved to make sure your application behaves accordingly. Endpoints discussed in this article: root/v1/user port/v1/users/ port/v1/clients/ port/v1/accounts/ Information regarding the three key entities that make up the organizational hierarchy in Saxo's systems is available in the OpenAPI on different endpoints located in the Root and Portfolio service groups. The configuration of these entities is static for the most part, and cannot be changed by users directly. The examples shown below are all taken from a default simulation developer account. This setup closely follows what a (direct) client of Saxo would be configured with in the live environment. A developer account can be created for free on the Developer Portal . Info The developer account client has a single associated user, and a single trading account with access to a limited subset of Saxo's entire instrument universe (Forex, CFDs, Equities, and Bonds). The endpoints discussed below generally come in three flavors, which allows you to interact with each resource in multiple ways: A .../me endpoint, which automatically returns the relevant information that is associated only to the currently logged-in client (identified by the token used to authorize the request). Example: port/v1/accounts/me . A .../{identifier} endpoint, which returns information about a specific user, client, or account entity using its unique ID. Example: port/v1/accounts/MXt3pDqb5VEujcdqBV1cmQ== . A collection such as port/v1/accounts/ , which returns all accounts associated with a client. User Permissions \u00b6 Before retrieving user, client, and account information from the Portfolio service group, let's first check the permissions of the currently logged-in user through the root/v1/user endpoint. This endpoint lives in the Root service group, which provides basic functionality for diagnostics, permissions, and session features. This service group does not require specific permissions in order to be used (i.e. any user can call these endpoints if they are authorized). HTTP GET /sim/openapi/root/v1/user HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] Accept : */* Cache-Control : no-cache Accept-Encoding : gzip, deflate, br Connection : keep-alive The response from the OpenAPI contains the below JSON object. Notice that the role assigned to this standard demo user (the developer account in the simulation system) is \"Default\" , which enables the \"OAPI.OP.View\" operation required to use the portfolio endpoints discussed below and pull out additional client details. Furthermore, this user has access right flag \"CanTrade\" set to true , which means it is authorized to place orders on the accounts owned by this client. { \"AccessRights\" : { ... \"CanTakePriceSession\" : true , \"CanTrade\" : true , ... }, \"ClientId\" : 9073876 , \"Operations\" : [ ... \"OAPI.OP.ViewOwnedClients\" , \"OAPI.OP.View\" , ... ], \"Roles\" : [ \"OAPI.Roles.Default\" ], \"UserId\" : 9073876 } Retrieving Details on Each Entity \u00b6 The procedure to obtain detailed information on the configuration of clients, users, and accounts follows a similarly-structured endpoints design. All of the below functionality is provided by the Portfolio service group, which not only contains configuration data for static entities, but also provides functionality to retrieve dynamic client data such as positions, orders, exposures, and account balances (which will be discussed in a later article). The below table describes each of the provided endpoints and their use cases. For most intends and purposes, the .../me endpoint suffices as it provides details that are directly relevant to the context of a single end-client user. The endpoints that return data by ID or in bulk are intended to be used by top-level client users to manage their hierarchy, although a single end-client user can obtain their data through these endpoints as well. Endpoint Functionality port/v1/users/me Returns user data for currently logged-in user. port/v1/users/{UserKey} Returns user data by user key. port/v1/users/?ClientKey={ClientKey} Return a list of all users associated to the provided client key. port/v1/clients/me Returns client data for client that the logged-in user belongs to. port/v1/clients/{ClientKey} Returns client data by client key. port/v1/clients/?OwnerKey={ClientKey} Return a list of clients owned by the provided owner key (client key). port/v1/accounts/me Returns all accounts for the client that the logged-in user belongs to. port/v1/accounts/{AccountKey} Returns account data by account key. port/v1/accounts/?ClientKey={ClientKey} Return a list of all accounts linked to the provided client key. Examples \u00b6 User Details \u00b6 Continuing the above example with the standard end-client user, let's retrieve data regarding this user by sending the below request to the OpenAPI. HTTP GET /sim/openapi/port/v1/user/me HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] Note The above request (and all following requests) are abbreviated for demonstration purposes. The response from the OpenAPI contains the below JSON object. Notice that this entity contains some important configuration such as localization settings, asset types that this user is allowed to trade, and whether the client is enabled to retrieve market data through the OpenAPI (details will be discussed in a later article). { \"ClientKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"Culture\" : \"en-US\" , \"Language\" : \"en\" , \"LastLoginStatus\" : \"Successful\" , \"LastLoginTime\" : \"2020-02-06T13:12:45.560000Z\" , \"LegalAssetTypes\" : [ \"FxSpot\" , \"Stock\" , \"CfdOnIndex\" , ... ], \"MarketDataViaOpenApiTermsAccepted\" : true , \"Name\" : \"User Name\" , \"TimeZoneId\" : 26 , \"UserId\" : \"9073876\" , \"UserKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" } Client Details \u00b6 In a similar vein, let's get more info on the client that this user belongs to through the below request. HTTP GET /sim/openapi/port/v1/clients/me HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] The below details are returned by the OpenAPI. Notice that accessible assets are controlled on the client level too, and the response includes further configuration such as position netting settings, the default currency, and the account protection limit (which is enforced on the client level as aggregate of the entire client's holdings). These concepts will be discussed in-depth in later articles. { \"AccountValueProtectionLimit\" : 500000 , \"ClientId\" : \"9073876\" , ... \"DefaultCurrency\" : \"EUR\" , \"ForceOpenDefaultValue\" : false , \"IsMarginTradingAllowed\" : true , \"IsVariationMarginEligible\" : false , \"LegalAssetTypes\" : [ \"FxSpot\" , \"Stock\" , \"CfdOnIndex\" , ... ], \"LegalAssetTypesAreIndicative\" : false , \"MarginCalculationMethod\" : \"Default\" , \"MarginMonitoringMode\" : \"Margin\" , \"MutualFundsCashAmountOrderCurrency\" : \"Instrument\" , \"Name\" : \"User Name\" , \"PositionNettingMode\" : \"EndOfDay\" , \"SupportsAccountValueProtectionLimit\" : true } Account Details \u00b6 And finally, let's check which accounts belong to this client. Notice the trailing slash at the end of the URI - in true REST fashion, this resource is a collection of account objects and therefore ends in a trailing slash (as opposed to the above examples which only return a single user or client object). HTTP GET /sim/openapi/port/v1/accounts/me/ HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] The API response contains a lot of settings and configurations that will be discussed in later articles. To highlight a few: accounts can be restricted to certain assets (like the users and clients), and some important configuration is included such as the account currency, display name, and type. Note Endpoints that return collections of objects generally follow the same structure with a \"Data\" field at the root of the returned JSON object. { \"Data\" : [ { \"AccountGroupKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"AccountId\" : \"9073876\" , \"AccountKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"AccountSubType\" : \"None\" , \"AccountType\" : \"Normal\" , \"Active\" : true , \"CanUseCashPositionsAsMarginCollateral\" : true , \"CfdBorrowingCostsActive\" : false , \"ClientId\" : \"9073876\" , \"ClientKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"CreationDate\" : \"2018-11-01T13:55:34.000000Z\" , \"Currency\" : \"EUR\" , \"CurrencyDecimals\" : 2 , \"DirectMarketAccess\" : false , \"DisplayName\" : \"My default account\" , \"IndividualMargining\" : false , \"IsCurrencyConversionAtSettlementTime\" : false , \"IsMarginTradingAllowed\" : true , \"IsShareable\" : false , \"IsTrialAccount\" : true , \"LegalAssetTypes\" : [ \"FxSpot\" , \"Stock\" , \"CfdOnIndex\" , ... ], \"MarginCalculationMethod\" : \"Default\" , \"Sharing\" : [ \"NoSharing\" ], \"SupportsAccountValueProtectionLimit\" : false , \"UseCashPositionsAsMarginCollateral\" : true } ] } Key Take-Aways \u00b6 Retrieving configuration information regarding the logged-in user, it's associated client, and the accounts it has access to is an essential part of the initialization process of any application that interacts with the OpenAPI. Typically, directly after the user logs in (i.e. an access token is obtained), the app is expected to call these endpoints to get a sense of the 'lay of the land' for this particular user. Querying the above endpoints provides answers to fundamental client-side questions that influence the way an application should behave, such as: Is the logged-in user allowed to trade on the client's accounts? What instruments does the client have access to? Is this user configured correctly to retrieve market data through the OpenAPI? What currency should be displayed by default in the UI? In addition, the configuration retrieved through these endpoints has a direct effect on the behavior of other endpoints across the OpenAPI. You might for instance try to place an order for an instrument that this particular client is not allowed to trade, or you might try to retrieve market data while the user is not configured appropriately, which results in errors. Info If you receive errors from endpoints in the OpenAPI that point at permissioning issues such as HTTP 403 Forbidden status codes or error messages along the lines of \"No Access\" , it is probably a good idea to double-check the configuration of the user through the above endpoints.","title":"Retrieving Entity Data"},{"location":"basics/core-business-concepts/retrieving-entity-data/#user-permissions","text":"Before retrieving user, client, and account information from the Portfolio service group, let's first check the permissions of the currently logged-in user through the root/v1/user endpoint. This endpoint lives in the Root service group, which provides basic functionality for diagnostics, permissions, and session features. This service group does not require specific permissions in order to be used (i.e. any user can call these endpoints if they are authorized). HTTP GET /sim/openapi/root/v1/user HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] Accept : */* Cache-Control : no-cache Accept-Encoding : gzip, deflate, br Connection : keep-alive The response from the OpenAPI contains the below JSON object. Notice that the role assigned to this standard demo user (the developer account in the simulation system) is \"Default\" , which enables the \"OAPI.OP.View\" operation required to use the portfolio endpoints discussed below and pull out additional client details. Furthermore, this user has access right flag \"CanTrade\" set to true , which means it is authorized to place orders on the accounts owned by this client. { \"AccessRights\" : { ... \"CanTakePriceSession\" : true , \"CanTrade\" : true , ... }, \"ClientId\" : 9073876 , \"Operations\" : [ ... \"OAPI.OP.ViewOwnedClients\" , \"OAPI.OP.View\" , ... ], \"Roles\" : [ \"OAPI.Roles.Default\" ], \"UserId\" : 9073876 }","title":"User Permissions"},{"location":"basics/core-business-concepts/retrieving-entity-data/#retrieving-details-on-each-entity","text":"The procedure to obtain detailed information on the configuration of clients, users, and accounts follows a similarly-structured endpoints design. All of the below functionality is provided by the Portfolio service group, which not only contains configuration data for static entities, but also provides functionality to retrieve dynamic client data such as positions, orders, exposures, and account balances (which will be discussed in a later article). The below table describes each of the provided endpoints and their use cases. For most intends and purposes, the .../me endpoint suffices as it provides details that are directly relevant to the context of a single end-client user. The endpoints that return data by ID or in bulk are intended to be used by top-level client users to manage their hierarchy, although a single end-client user can obtain their data through these endpoints as well. Endpoint Functionality port/v1/users/me Returns user data for currently logged-in user. port/v1/users/{UserKey} Returns user data by user key. port/v1/users/?ClientKey={ClientKey} Return a list of all users associated to the provided client key. port/v1/clients/me Returns client data for client that the logged-in user belongs to. port/v1/clients/{ClientKey} Returns client data by client key. port/v1/clients/?OwnerKey={ClientKey} Return a list of clients owned by the provided owner key (client key). port/v1/accounts/me Returns all accounts for the client that the logged-in user belongs to. port/v1/accounts/{AccountKey} Returns account data by account key. port/v1/accounts/?ClientKey={ClientKey} Return a list of all accounts linked to the provided client key.","title":"Retrieving Details on Each Entity"},{"location":"basics/core-business-concepts/retrieving-entity-data/#examples","text":"","title":"Examples"},{"location":"basics/core-business-concepts/retrieving-entity-data/#user-details","text":"Continuing the above example with the standard end-client user, let's retrieve data regarding this user by sending the below request to the OpenAPI. HTTP GET /sim/openapi/port/v1/user/me HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] Note The above request (and all following requests) are abbreviated for demonstration purposes. The response from the OpenAPI contains the below JSON object. Notice that this entity contains some important configuration such as localization settings, asset types that this user is allowed to trade, and whether the client is enabled to retrieve market data through the OpenAPI (details will be discussed in a later article). { \"ClientKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"Culture\" : \"en-US\" , \"Language\" : \"en\" , \"LastLoginStatus\" : \"Successful\" , \"LastLoginTime\" : \"2020-02-06T13:12:45.560000Z\" , \"LegalAssetTypes\" : [ \"FxSpot\" , \"Stock\" , \"CfdOnIndex\" , ... ], \"MarketDataViaOpenApiTermsAccepted\" : true , \"Name\" : \"User Name\" , \"TimeZoneId\" : 26 , \"UserId\" : \"9073876\" , \"UserKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" }","title":"User Details"},{"location":"basics/core-business-concepts/retrieving-entity-data/#client-details","text":"In a similar vein, let's get more info on the client that this user belongs to through the below request. HTTP GET /sim/openapi/port/v1/clients/me HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] The below details are returned by the OpenAPI. Notice that accessible assets are controlled on the client level too, and the response includes further configuration such as position netting settings, the default currency, and the account protection limit (which is enforced on the client level as aggregate of the entire client's holdings). These concepts will be discussed in-depth in later articles. { \"AccountValueProtectionLimit\" : 500000 , \"ClientId\" : \"9073876\" , ... \"DefaultCurrency\" : \"EUR\" , \"ForceOpenDefaultValue\" : false , \"IsMarginTradingAllowed\" : true , \"IsVariationMarginEligible\" : false , \"LegalAssetTypes\" : [ \"FxSpot\" , \"Stock\" , \"CfdOnIndex\" , ... ], \"LegalAssetTypesAreIndicative\" : false , \"MarginCalculationMethod\" : \"Default\" , \"MarginMonitoringMode\" : \"Margin\" , \"MutualFundsCashAmountOrderCurrency\" : \"Instrument\" , \"Name\" : \"User Name\" , \"PositionNettingMode\" : \"EndOfDay\" , \"SupportsAccountValueProtectionLimit\" : true }","title":"Client Details"},{"location":"basics/core-business-concepts/retrieving-entity-data/#account-details","text":"And finally, let's check which accounts belong to this client. Notice the trailing slash at the end of the URI - in true REST fashion, this resource is a collection of account objects and therefore ends in a trailing slash (as opposed to the above examples which only return a single user or client object). HTTP GET /sim/openapi/port/v1/accounts/me/ HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] The API response contains a lot of settings and configurations that will be discussed in later articles. To highlight a few: accounts can be restricted to certain assets (like the users and clients), and some important configuration is included such as the account currency, display name, and type. Note Endpoints that return collections of objects generally follow the same structure with a \"Data\" field at the root of the returned JSON object. { \"Data\" : [ { \"AccountGroupKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"AccountId\" : \"9073876\" , \"AccountKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"AccountSubType\" : \"None\" , \"AccountType\" : \"Normal\" , \"Active\" : true , \"CanUseCashPositionsAsMarginCollateral\" : true , \"CfdBorrowingCostsActive\" : false , \"ClientId\" : \"9073876\" , \"ClientKey\" : \"X1JlUyeXTMK3mBxzd-D2UA==\" , \"CreationDate\" : \"2018-11-01T13:55:34.000000Z\" , \"Currency\" : \"EUR\" , \"CurrencyDecimals\" : 2 , \"DirectMarketAccess\" : false , \"DisplayName\" : \"My default account\" , \"IndividualMargining\" : false , \"IsCurrencyConversionAtSettlementTime\" : false , \"IsMarginTradingAllowed\" : true , \"IsShareable\" : false , \"IsTrialAccount\" : true , \"LegalAssetTypes\" : [ \"FxSpot\" , \"Stock\" , \"CfdOnIndex\" , ... ], \"MarginCalculationMethod\" : \"Default\" , \"Sharing\" : [ \"NoSharing\" ], \"SupportsAccountValueProtectionLimit\" : false , \"UseCashPositionsAsMarginCollateral\" : true } ] }","title":"Account Details"},{"location":"basics/core-business-concepts/retrieving-entity-data/#key-take-aways","text":"Retrieving configuration information regarding the logged-in user, it's associated client, and the accounts it has access to is an essential part of the initialization process of any application that interacts with the OpenAPI. Typically, directly after the user logs in (i.e. an access token is obtained), the app is expected to call these endpoints to get a sense of the 'lay of the land' for this particular user. Querying the above endpoints provides answers to fundamental client-side questions that influence the way an application should behave, such as: Is the logged-in user allowed to trade on the client's accounts? What instruments does the client have access to? Is this user configured correctly to retrieve market data through the OpenAPI? What currency should be displayed by default in the UI? In addition, the configuration retrieved through these endpoints has a direct effect on the behavior of other endpoints across the OpenAPI. You might for instance try to place an order for an instrument that this particular client is not allowed to trade, or you might try to retrieve market data while the user is not configured appropriately, which results in errors. Info If you receive errors from endpoints in the OpenAPI that point at permissioning issues such as HTTP 403 Forbidden status codes or error messages along the lines of \"No Access\" , it is probably a good idea to double-check the configuration of the user through the above endpoints.","title":"Key Take-Aways"},{"location":"basics/faq/","text":"","title":"FAQ Guide"},{"location":"basics/faq/authentication/","text":"","title":"How do I authenticate?"},{"location":"basics/fundamental-programming-concepts/","text":"","title":"Overview"},{"location":"basics/fundamental-programming-concepts/code-sample/","text":"Rendering sample files directly in the article page \u00b6 GO TO CODE SAMPLE This is HTML directly imported from the code sample living elsewhere in the repository: \ufeffToken (from developer.saxobank.com/openapi/token ): Context ID: Launch SaxoTraderGO as primary - For extending subscriptions and disconnecting, see order update events example. \ufeff/*jslint this: true, browser: true, for: true, long: true */ /*global console */ var accountKey = \"\"; /** * Shared function to display an unsuccessful response. * @param {Object} errorObject The complete error object. * @return {void} */ function processError(errorObject) { var textToDisplay = \"Error with status \" + errorObject.status + \" \" + errorObject.statusText; console.error(textToDisplay + \" \" + errorObject.url); // Some errors have a JSON-response, containing explanation of what went wrong. errorObject.json().then(function (errorObjectJson) { if (errorObjectJson.hasOwnProperty(\"ErrorInfo\")) { // Order error object is wrapped in ErrorInfo errorObjectJson = errorObjectJson.ErrorInfo; } // Order preview error object not.. if (errorObjectJson.hasOwnProperty(\"ErrorCode\")) { textToDisplay += \" - \" + errorObjectJson.ErrorCode + \" (\" + errorObjectJson.Message + \")\"; } document.getElementById(\"idResponse\").innerText = textToDisplay; }).catch(function (ignore) { // Typically 401 (Unauthorized) has an empty response, this generates a SyntaxError. document.getElementById(\"idResponse\").innerText = textToDisplay; }); } /** * Show a function and run it. * @param {Function} functionToRun The function in scope. * @return {void} */ function run(functionToRun) { // Display source used for demonstration: document.getElementById(\"idJavaScript\").innerText = functionToRun.toString(); if (document.getElementById(\"idBearerToken\").value === \"\") { document.getElementById(\"idResponse\").innerText = \"Bearer token is required to do requests.\"; } else { if (accountKey === \"\") { // Retrieve the account key first fetch( \"https://gateway.saxobank.com/sim/openapi/port/v1/accounts/me\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"GET\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { accountKey = responseJson.Data[0].AccountKey; // Just get the first account console.log(\"Using accountKey: \" + accountKey); functionToRun(); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } else { functionToRun(); } } } (function () { /** * Read a cookie. * @param {string} key Name of the cookie. * @return {string} Value. */ function getCookie(key) { var name = key + \"=\"; var decodedCookie = decodeURIComponent(document.cookie); var cookieArray = decodedCookie.split(\";\"); var i; var c; for (i = 0; i < cookieArray.length; i += 1) { c = cookieArray[i]; while (c.charAt(0) === \" \") { c = c.substring(1); } if (c.indexOf(name) === 0) { return c.substring(name.length, c.length); } } return \"\"; } /** * Insert a cookie. In order to delete it, make value empty. * @param {string} key Name of the cookie. * @param {string} value Value to store. * @return {void} */ function setCookie(key, value) { var expires = new Date(); // Cookie is valid for 360 days. expires.setTime(expires.getTime() + 360 * 24 * 60 * 60 * 1000); document.cookie = key + \"=\" + value + \";expires=\" + expires.toUTCString(); } // Show most recent used token: var previouslyUsedToken = getCookie(\"saxotoken\"); if (previouslyUsedToken !== \"\") { document.getElementById(\"idBearerToken\").value = previouslyUsedToken; } window.addEventListener(\"beforeunload\", function () { var token = document.getElementById(\"idBearerToken\").value; if (token.length > 10) { // Save the token so it can be reused: setCookie(\"saxotoken\", token); } }); }()); \ufeff/*jslint this: true, browser: true, for: true, long: true */ /*global window console WebSocket accountKey run processError */ var connection; /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function createConnection() { var accessToken = document.getElementById(\"idBearerToken\").value; var contextId = encodeURIComponent(document.getElementById(\"idContextId\").value); var streamerUrl = \"wss://gateway.saxobank.com/sim/openapi/streamingws/connect?authorization=\" + encodeURIComponent(\"BEARER \" + accessToken) + \"&contextId=\" + contextId; connection = new WebSocket(streamerUrl); document.getElementById(\"idResponse\").innerText = \"Connection created. ReadyState: \" + connection.readyState; // Documentation on readyState: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState // 0 = CONNECTING, 1 = OPEN } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function startListener() { function parseStreamingMessage(data) { try { var message = new DataView(data); var bytes = new Uint8Array(data); var messageId = message.getInt8(); var refBeginIndex = 10; var refIdLength = message.getInt8(refBeginIndex); var refId = String.fromCharCode.apply(String, bytes.slice(refBeginIndex + 1, refBeginIndex + 1 + refIdLength)); var payloadBeginIndex = refBeginIndex + 1 + refIdLength; var payloadLength = message.getUint32(payloadBeginIndex + 1, true); var segmentEnd = payloadBeginIndex + 5 + payloadLength; var payload = String.fromCharCode.apply(String, bytes.slice(payloadBeginIndex + 5, segmentEnd)); var block = JSON.parse(payload); console.log(\"Message \" + messageId + \" parsed with referenceId \" + refId + \" and payload: \" + payload); block.ReferenceId = refId; block.MessageID = messageId; switch (refId) { case \"MyTradeLevelChangeEvent\": document.getElementById(\"idResponse\").innerText = \"Streaming message received: \" + payload; break; case \"_heartbeat\": break; default: console.log(\"No processing implemented for message with reference \" + refId); } return { \"segmentEnd\": segmentEnd, \"messages\": block }; } catch (error) { console.error(\"Parse message failed: \" + error); } } connection.onmessage = function (event) { // Documentation on message format: https://www.developer.saxo/openapi/learn/plain-websocket-streaming#PlainWebSocketStreaming-Receivingmessages var reader = new FileReader(); console.log(\"Streaming message received\"); reader.readAsArrayBuffer(event.data); reader.onloadend = function () { var beginAt = 0; var data = reader.result; var parsedMessage; do { parsedMessage = parseStreamingMessage(data); beginAt = parsedMessage.segmentEnd; data = data.slice(beginAt); } while (data.byteLength > 0); }; }; document.getElementById(\"idResponse\").innerText = \"Connection subscribed to events. ReadyState: \" + connection.readyState; } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function subscribe() { var data = { \"ContextId\": encodeURIComponent(document.getElementById(\"idContextId\").value), \"ReferenceId\": \"MyTradeLevelChangeEvent\" }; fetch(\"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/events/subscriptions\", { \"method\": \"POST\", \"headers\": { \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value, \"Content-Type\": \"application/json\" }, \"body\": JSON.stringify(data) }); document.getElementById(\"idResponse\").innerText = \"Subscription created. ReadyState: \" + connection.readyState; } /** * This is an example of making the current app primary, so real time prices can be shown. Other apps are notified and get delayed prices. * @return {void} */ function becomePrimary() { fetch( \"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/capabilities\", { \"headers\": { \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value, \"Content-Type\": \"application/json; charset=utf-8\" }, \"body\": JSON.stringify({ \"TradeLevel\": \"FullTradingAndChat\" }), \"method\": \"PUT\" } ).then(function (response) { if (response.ok) { document.getElementById(\"idResponse\").innerText = \"Requested to become primary\"; } else { processError(response); } }).catch(function (error) { processError(error); }); } document.getElementById(\"idContextId\").value = \"MyApp_\" + Date.now(); document.getElementById(\"idBtnCreateConnection\").addEventListener(\"click\", function () { run(createConnection); }); document.getElementById(\"idBtnStartListener\").addEventListener(\"click\", function () { run(startListener); }); document.getElementById(\"idBtnSubscribe\").addEventListener(\"click\", function () { run(subscribe); }); document.getElementById(\"idBtnBecomePrimary\").addEventListener(\"click\", function () { run(becomePrimary); }); Code sample from file: \u00b6 This code sample is directly pulled in from the src folder in this repo's root directory. It is NOT included in the markdown but instead directly rendered from the source file, meaning that any updates and changes are taken straight 'from the source'. JS /*jslint this: true, browser: true, for: true, long: true */ /*global window console WebSocket accountKey run processError */ var connection ; /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function createConnection () { var accessToken = document . getElementById ( \"idBearerToken\" ). value ; var contextId = encodeURIComponent ( document . getElementById ( \"idContextId\" ). value ); var streamerUrl = \"wss://gateway.saxobank.com/sim/openapi/streamingws/connect?authorization=\" + encodeURIComponent ( \"BEARER \" + accessToken ) + \"&contextId=\" + contextId ; connection = new WebSocket ( streamerUrl ); document . getElementById ( \"idResponse\" ). innerText = \"Connection created. ReadyState: \" + connection . readyState ; // Documentation on readyState: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState // 0 = CONNECTING, 1 = OPEN } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function startListener () { function parseStreamingMessage ( data ) { try { var message = new DataView ( data ); var bytes = new Uint8Array ( data ); var messageId = message . getInt8 (); var refBeginIndex = 10 ; var refIdLength = message . getInt8 ( refBeginIndex ); var refId = String . fromCharCode . apply ( String , bytes . slice ( refBeginIndex + 1 , refBeginIndex + 1 + refIdLength )); var payloadBeginIndex = refBeginIndex + 1 + refIdLength ; var payloadLength = message . getUint32 ( payloadBeginIndex + 1 , true ); var segmentEnd = payloadBeginIndex + 5 + payloadLength ; var payload = String . fromCharCode . apply ( String , bytes . slice ( payloadBeginIndex + 5 , segmentEnd )); var block = JSON . parse ( payload ); console . log ( \"Message \" + messageId + \" parsed with referenceId \" + refId + \" and payload: \" + payload ); block . ReferenceId = refId ; block . MessageID = messageId ; switch ( refId ) { case \"MyTradeLevelChangeEvent\" : document . getElementById ( \"idResponse\" ). innerText = \"Streaming message received: \" + payload ; break ; case \"_heartbeat\" : break ; default : console . log ( \"No processing implemented for message with reference \" + refId ); } return { \"segmentEnd\" : segmentEnd , \"messages\" : block }; } catch ( error ) { console . error ( \"Parse message failed: \" + error ); } } connection . onmessage = function ( event ) { // Documentation on message format: https://www.developer.saxo/openapi/learn/plain-websocket-streaming#PlainWebSocketStreaming-Receivingmessages var reader = new FileReader (); console . log ( \"Streaming message received\" ); reader . readAsArrayBuffer ( event . data ); reader . onloadend = function () { var beginAt = 0 ; var data = reader . result ; var parsedMessage ; do { parsedMessage = parseStreamingMessage ( data ); beginAt = parsedMessage . segmentEnd ; data = data . slice ( beginAt ); } while ( data . byteLength > 0 ); }; }; document . getElementById ( \"idResponse\" ). innerText = \"Connection subscribed to events. ReadyState: \" + connection . readyState ; } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function subscribe () { var data = { \"ContextId\" : encodeURIComponent ( document . getElementById ( \"idContextId\" ). value ), \"ReferenceId\" : \"MyTradeLevelChangeEvent\" }; fetch ( \"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/events/subscriptions\" , { \"method\" : \"POST\" , \"headers\" : { \"Authorization\" : \"Bearer \" + document . getElementById ( \"idBearerToken\" ). value , \"Content-Type\" : \"application/json\" }, \"body\" : JSON . stringify ( data ) }); document . getElementById ( \"idResponse\" ). innerText = \"Subscription created. ReadyState: \" + connection . readyState ; } /** * This is an example of making the current app primary, so real time prices can be shown. Other apps are notified and get delayed prices. * @return {void} */ function becomePrimary () { fetch ( \"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/capabilities\" , { \"headers\" : { \"Authorization\" : \"Bearer \" + document . getElementById ( \"idBearerToken\" ). value , \"Content-Type\" : \"application/json; charset=utf-8\" }, \"body\" : JSON . stringify ({ \"TradeLevel\" : \"FullTradingAndChat\" }), \"method\" : \"PUT\" } ). then ( function ( response ) { if ( response . ok ) { document . getElementById ( \"idResponse\" ). innerText = \"Requested to become primary\" ; } else { processError ( response ); } }). catch ( function ( error ) { processError ( error ); }); } document . getElementById ( \"idContextId\" ). value = \"MyApp_\" + Date . now (); document . getElementById ( \"idBtnCreateConnection\" ). addEventListener ( \"click\" , function () { run ( createConnection ); }); document . getElementById ( \"idBtnStartListener\" ). addEventListener ( \"click\" , function () { run ( startListener ); }); document . getElementById ( \"idBtnSubscribe\" ). addEventListener ( \"click\" , function () { run ( subscribe ); }); document . getElementById ( \"idBtnBecomePrimary\" ). addEventListener ( \"click\" , function () { run ( becomePrimary ); });","title":"Code Sample"},{"location":"basics/fundamental-programming-concepts/code-sample/#rendering-sample-files-directly-in-the-article-page","text":"GO TO CODE SAMPLE This is HTML directly imported from the code sample living elsewhere in the repository: \ufeffToken (from developer.saxobank.com/openapi/token ): Context ID: Launch SaxoTraderGO as primary - For extending subscriptions and disconnecting, see order update events example. \ufeff/*jslint this: true, browser: true, for: true, long: true */ /*global console */ var accountKey = \"\"; /** * Shared function to display an unsuccessful response. * @param {Object} errorObject The complete error object. * @return {void} */ function processError(errorObject) { var textToDisplay = \"Error with status \" + errorObject.status + \" \" + errorObject.statusText; console.error(textToDisplay + \" \" + errorObject.url); // Some errors have a JSON-response, containing explanation of what went wrong. errorObject.json().then(function (errorObjectJson) { if (errorObjectJson.hasOwnProperty(\"ErrorInfo\")) { // Order error object is wrapped in ErrorInfo errorObjectJson = errorObjectJson.ErrorInfo; } // Order preview error object not.. if (errorObjectJson.hasOwnProperty(\"ErrorCode\")) { textToDisplay += \" - \" + errorObjectJson.ErrorCode + \" (\" + errorObjectJson.Message + \")\"; } document.getElementById(\"idResponse\").innerText = textToDisplay; }).catch(function (ignore) { // Typically 401 (Unauthorized) has an empty response, this generates a SyntaxError. document.getElementById(\"idResponse\").innerText = textToDisplay; }); } /** * Show a function and run it. * @param {Function} functionToRun The function in scope. * @return {void} */ function run(functionToRun) { // Display source used for demonstration: document.getElementById(\"idJavaScript\").innerText = functionToRun.toString(); if (document.getElementById(\"idBearerToken\").value === \"\") { document.getElementById(\"idResponse\").innerText = \"Bearer token is required to do requests.\"; } else { if (accountKey === \"\") { // Retrieve the account key first fetch( \"https://gateway.saxobank.com/sim/openapi/port/v1/accounts/me\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"GET\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { accountKey = responseJson.Data[0].AccountKey; // Just get the first account console.log(\"Using accountKey: \" + accountKey); functionToRun(); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } else { functionToRun(); } } } (function () { /** * Read a cookie. * @param {string} key Name of the cookie. * @return {string} Value. */ function getCookie(key) { var name = key + \"=\"; var decodedCookie = decodeURIComponent(document.cookie); var cookieArray = decodedCookie.split(\";\"); var i; var c; for (i = 0; i < cookieArray.length; i += 1) { c = cookieArray[i]; while (c.charAt(0) === \" \") { c = c.substring(1); } if (c.indexOf(name) === 0) { return c.substring(name.length, c.length); } } return \"\"; } /** * Insert a cookie. In order to delete it, make value empty. * @param {string} key Name of the cookie. * @param {string} value Value to store. * @return {void} */ function setCookie(key, value) { var expires = new Date(); // Cookie is valid for 360 days. expires.setTime(expires.getTime() + 360 * 24 * 60 * 60 * 1000); document.cookie = key + \"=\" + value + \";expires=\" + expires.toUTCString(); } // Show most recent used token: var previouslyUsedToken = getCookie(\"saxotoken\"); if (previouslyUsedToken !== \"\") { document.getElementById(\"idBearerToken\").value = previouslyUsedToken; } window.addEventListener(\"beforeunload\", function () { var token = document.getElementById(\"idBearerToken\").value; if (token.length > 10) { // Save the token so it can be reused: setCookie(\"saxotoken\", token); } }); }()); \ufeff/*jslint this: true, browser: true, for: true, long: true */ /*global window console WebSocket accountKey run processError */ var connection; /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function createConnection() { var accessToken = document.getElementById(\"idBearerToken\").value; var contextId = encodeURIComponent(document.getElementById(\"idContextId\").value); var streamerUrl = \"wss://gateway.saxobank.com/sim/openapi/streamingws/connect?authorization=\" + encodeURIComponent(\"BEARER \" + accessToken) + \"&contextId=\" + contextId; connection = new WebSocket(streamerUrl); document.getElementById(\"idResponse\").innerText = \"Connection created. ReadyState: \" + connection.readyState; // Documentation on readyState: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState // 0 = CONNECTING, 1 = OPEN } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function startListener() { function parseStreamingMessage(data) { try { var message = new DataView(data); var bytes = new Uint8Array(data); var messageId = message.getInt8(); var refBeginIndex = 10; var refIdLength = message.getInt8(refBeginIndex); var refId = String.fromCharCode.apply(String, bytes.slice(refBeginIndex + 1, refBeginIndex + 1 + refIdLength)); var payloadBeginIndex = refBeginIndex + 1 + refIdLength; var payloadLength = message.getUint32(payloadBeginIndex + 1, true); var segmentEnd = payloadBeginIndex + 5 + payloadLength; var payload = String.fromCharCode.apply(String, bytes.slice(payloadBeginIndex + 5, segmentEnd)); var block = JSON.parse(payload); console.log(\"Message \" + messageId + \" parsed with referenceId \" + refId + \" and payload: \" + payload); block.ReferenceId = refId; block.MessageID = messageId; switch (refId) { case \"MyTradeLevelChangeEvent\": document.getElementById(\"idResponse\").innerText = \"Streaming message received: \" + payload; break; case \"_heartbeat\": break; default: console.log(\"No processing implemented for message with reference \" + refId); } return { \"segmentEnd\": segmentEnd, \"messages\": block }; } catch (error) { console.error(\"Parse message failed: \" + error); } } connection.onmessage = function (event) { // Documentation on message format: https://www.developer.saxo/openapi/learn/plain-websocket-streaming#PlainWebSocketStreaming-Receivingmessages var reader = new FileReader(); console.log(\"Streaming message received\"); reader.readAsArrayBuffer(event.data); reader.onloadend = function () { var beginAt = 0; var data = reader.result; var parsedMessage; do { parsedMessage = parseStreamingMessage(data); beginAt = parsedMessage.segmentEnd; data = data.slice(beginAt); } while (data.byteLength > 0); }; }; document.getElementById(\"idResponse\").innerText = \"Connection subscribed to events. ReadyState: \" + connection.readyState; } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function subscribe() { var data = { \"ContextId\": encodeURIComponent(document.getElementById(\"idContextId\").value), \"ReferenceId\": \"MyTradeLevelChangeEvent\" }; fetch(\"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/events/subscriptions\", { \"method\": \"POST\", \"headers\": { \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value, \"Content-Type\": \"application/json\" }, \"body\": JSON.stringify(data) }); document.getElementById(\"idResponse\").innerText = \"Subscription created. ReadyState: \" + connection.readyState; } /** * This is an example of making the current app primary, so real time prices can be shown. Other apps are notified and get delayed prices. * @return {void} */ function becomePrimary() { fetch( \"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/capabilities\", { \"headers\": { \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value, \"Content-Type\": \"application/json; charset=utf-8\" }, \"body\": JSON.stringify({ \"TradeLevel\": \"FullTradingAndChat\" }), \"method\": \"PUT\" } ).then(function (response) { if (response.ok) { document.getElementById(\"idResponse\").innerText = \"Requested to become primary\"; } else { processError(response); } }).catch(function (error) { processError(error); }); } document.getElementById(\"idContextId\").value = \"MyApp_\" + Date.now(); document.getElementById(\"idBtnCreateConnection\").addEventListener(\"click\", function () { run(createConnection); }); document.getElementById(\"idBtnStartListener\").addEventListener(\"click\", function () { run(startListener); }); document.getElementById(\"idBtnSubscribe\").addEventListener(\"click\", function () { run(subscribe); }); document.getElementById(\"idBtnBecomePrimary\").addEventListener(\"click\", function () { run(becomePrimary); });","title":"Rendering sample files directly in the article page"},{"location":"basics/fundamental-programming-concepts/code-sample/#code-sample-from-file","text":"This code sample is directly pulled in from the src folder in this repo's root directory. It is NOT included in the markdown but instead directly rendered from the source file, meaning that any updates and changes are taken straight 'from the source'. JS /*jslint this: true, browser: true, for: true, long: true */ /*global window console WebSocket accountKey run processError */ var connection ; /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function createConnection () { var accessToken = document . getElementById ( \"idBearerToken\" ). value ; var contextId = encodeURIComponent ( document . getElementById ( \"idContextId\" ). value ); var streamerUrl = \"wss://gateway.saxobank.com/sim/openapi/streamingws/connect?authorization=\" + encodeURIComponent ( \"BEARER \" + accessToken ) + \"&contextId=\" + contextId ; connection = new WebSocket ( streamerUrl ); document . getElementById ( \"idResponse\" ). innerText = \"Connection created. ReadyState: \" + connection . readyState ; // Documentation on readyState: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState // 0 = CONNECTING, 1 = OPEN } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function startListener () { function parseStreamingMessage ( data ) { try { var message = new DataView ( data ); var bytes = new Uint8Array ( data ); var messageId = message . getInt8 (); var refBeginIndex = 10 ; var refIdLength = message . getInt8 ( refBeginIndex ); var refId = String . fromCharCode . apply ( String , bytes . slice ( refBeginIndex + 1 , refBeginIndex + 1 + refIdLength )); var payloadBeginIndex = refBeginIndex + 1 + refIdLength ; var payloadLength = message . getUint32 ( payloadBeginIndex + 1 , true ); var segmentEnd = payloadBeginIndex + 5 + payloadLength ; var payload = String . fromCharCode . apply ( String , bytes . slice ( payloadBeginIndex + 5 , segmentEnd )); var block = JSON . parse ( payload ); console . log ( \"Message \" + messageId + \" parsed with referenceId \" + refId + \" and payload: \" + payload ); block . ReferenceId = refId ; block . MessageID = messageId ; switch ( refId ) { case \"MyTradeLevelChangeEvent\" : document . getElementById ( \"idResponse\" ). innerText = \"Streaming message received: \" + payload ; break ; case \"_heartbeat\" : break ; default : console . log ( \"No processing implemented for message with reference \" + refId ); } return { \"segmentEnd\" : segmentEnd , \"messages\" : block }; } catch ( error ) { console . error ( \"Parse message failed: \" + error ); } } connection . onmessage = function ( event ) { // Documentation on message format: https://www.developer.saxo/openapi/learn/plain-websocket-streaming#PlainWebSocketStreaming-Receivingmessages var reader = new FileReader (); console . log ( \"Streaming message received\" ); reader . readAsArrayBuffer ( event . data ); reader . onloadend = function () { var beginAt = 0 ; var data = reader . result ; var parsedMessage ; do { parsedMessage = parseStreamingMessage ( data ); beginAt = parsedMessage . segmentEnd ; data = data . slice ( beginAt ); } while ( data . byteLength > 0 ); }; }; document . getElementById ( \"idResponse\" ). innerText = \"Connection subscribed to events. ReadyState: \" + connection . readyState ; } /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function subscribe () { var data = { \"ContextId\" : encodeURIComponent ( document . getElementById ( \"idContextId\" ). value ), \"ReferenceId\" : \"MyTradeLevelChangeEvent\" }; fetch ( \"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/events/subscriptions\" , { \"method\" : \"POST\" , \"headers\" : { \"Authorization\" : \"Bearer \" + document . getElementById ( \"idBearerToken\" ). value , \"Content-Type\" : \"application/json\" }, \"body\" : JSON . stringify ( data ) }); document . getElementById ( \"idResponse\" ). innerText = \"Subscription created. ReadyState: \" + connection . readyState ; } /** * This is an example of making the current app primary, so real time prices can be shown. Other apps are notified and get delayed prices. * @return {void} */ function becomePrimary () { fetch ( \"https://gateway.saxobank.com/sim/openapi/root/v1/sessions/capabilities\" , { \"headers\" : { \"Authorization\" : \"Bearer \" + document . getElementById ( \"idBearerToken\" ). value , \"Content-Type\" : \"application/json; charset=utf-8\" }, \"body\" : JSON . stringify ({ \"TradeLevel\" : \"FullTradingAndChat\" }), \"method\" : \"PUT\" } ). then ( function ( response ) { if ( response . ok ) { document . getElementById ( \"idResponse\" ). innerText = \"Requested to become primary\" ; } else { processError ( response ); } }). catch ( function ( error ) { processError ( error ); }); } document . getElementById ( \"idContextId\" ). value = \"MyApp_\" + Date . now (); document . getElementById ( \"idBtnCreateConnection\" ). addEventListener ( \"click\" , function () { run ( createConnection ); }); document . getElementById ( \"idBtnStartListener\" ). addEventListener ( \"click\" , function () { run ( startListener ); }); document . getElementById ( \"idBtnSubscribe\" ). addEventListener ( \"click\" , function () { run ( subscribe ); }); document . getElementById ( \"idBtnBecomePrimary\" ). addEventListener ( \"click\" , function () { run ( becomePrimary ); });","title":"Code sample from file:"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/","text":"Abstract This article provides an in-depth walkthrough of the OpenAPI WebSocket implementation. It is recommended for anyone working on OpenAPI streaming to study the below carefully, as it includes important considerations around correct management of WebSocket connections and optimal use of this solution. Introduction \u00b6 The OpenAPI supports streaming using a standard implementation of the WebSocket Protocol, as described in RFC6455 . Given that most of the information available to users is in constant flux (such as account balance, charts, quotes, position P&L, etc), using polling for each dynamic element that could be relevant in an application is not a viable solution. Instead, creating a single WebSocket connection and adding/removing subscriptions on-demand offers greatly reduced overhead and optimal latency. 1 In a standard use-case, an application (web, mobile, or native) creates a WebSocket connection and subscribes to the data that it requires. The subscriptions change constantly (depending on the contextual requirements) while the WebSocket connection persists. This allows for a fairly lean setup: the connection is created once (the 'channel'), and the data sent over this connection is controlled with individual POST and DELETE requests to the associated OpenAPI endpoints. The majority of endpoints support subscriptions alongside standard GET requests, which can be identified by the .../subscriptions suffix. Some examples: port/v1/netpositions/subscriptions/ , which provides real-time updates of net positions across a client's accounts. This includes details such as Exposure , ProfitLossOnTrade , and ConversionRateCurrent , which is used to convert between instrument currency and account currency in real time. chart/v1/charts/subscriptions/ , which is used to retrieve live OHLC data and (recent) historic bars, which lays the groundworks for interactive charts, indicators, strategies, etc. trade/v1/infoprices/subscriptions/ , which is used to retrieve 'informational' prices for display purposes in product overviews, chart overlays, and watchlists. This endpoint also includes functionality to retrieve in-depth price details such as daily high/low and %-change values. Depending on the specific context, an (imaginary) application might for instance follow the below sequence of OpenAPI operations while the user interacts with its UI: When a user logs on, the app creates a WebSocket connection which will be used throughout the below steps. While the UI loads, the app subscribes to port/v1/balances/subscriptions/ to show the client an overview of their current account state. This is a persistent element in the UI and the subscription will be kept alive for as long as the client is using the app. The app has a feature to draw charts, and the user selects the EURUSD Forex cross as the instrument for this chart. The app subscribes to chart/v1/charts/subscriptions/ to simultaneously create a live-updating price stream and obtain historic bars. The user switches to EURGBP in the chart. The app deletes the previous subscription as this is not longer required, and re-subscribes to chart/v1/charts/subscriptions/ to pull out data for EURGBP. The user closes the app. Any remaining subscriptions are removed and the WebSocket connection is closed. Note that all data in the above example is transferred over a single persistent 'channel' (the WebSocket connection). Overview of WebSocket Streaming \u00b6 sequenceDiagram participant C as Client Application participant S as OpenAPI <br> WebSocket Server participant O as OpenAPI <br> Endpoints C->>S: 1 - Initiate Connection S->>C: 2 - Receive Confirmation C->>O: 3 - Create Subscription O->>C: 4 - Receive Snapshot Data O->>S: 5 - Initiate Streaming loop streaming S-->>C: 6 - Receive Updates end The sequence above represents the standard flow to create a new WebSocket connection and subscribe to streaming data. It involves the following processes: Initiate Connection. The client application creates a WebSocket connection by sending a request to the OpenAPI WebSocket Server (or 'streaming server', which is located on streaming.saxobank.com ). This request, also called the 'opening handshake', follows standard WebSocket protocol and includes two additional elements: The ContextId parameter: a unique ID that identifies this connection. This ID is generated by the client application. Every API interaction that involves streaming should include this ID (see step 3 below). Example: ContextId=MyApp123abc . Make sure to create a sufficiently long random string to prevent potential clashes with other applications. The streaming server will respond with HTTP 409 Conflict if the ContextId is already used for a different connection. The Authorization header: standard authorization header containing a valid access token. Can also be sent as parameter if the client-side library does not support initiating WebSocket connections with custom headers. Example: Authorization=Bearer%20[token] . With Auth Header GET /sim/openapi/streamingws/connect?ContextId=[ID] HTTP / 1.1 Host : streaming.saxobank.com Authorization : Bearer [token] Connection : Upgrade Upgrade : WebSocket Sec-WebSocket-Key : [auto-generated key] Sec-WebSocket-Version : 13 With Auth Parameter GET /sim/openapi/streamingws/connect?ContextId=[ID]&Authorization=Bearer%20[token] HTTP / 1.1 Host : streaming.saxobank.com Connection : Upgrade Upgrade : WebSocket Sec-WebSocket-Key : [auto-generated key] Sec-WebSocket-Version : 13 Caution In many client-side libraries, the URL that is required to initiate a WebSocket connection is usually composed as: wss://host/path , replacing the http protocol prefix (which is only used on initiation - the connection is upgraded afterwards). In JavaScript for example, initiating a WebSocket connection requires the following code: let connection = new WebSocket ( \"wss://example.com/streaming?parameter=123\" ) Note The current WebSocket version supported by the OpenAPI is 13 . Client libraries using outdated versions will receive a HTTP 426 Upgrade Required response when attempting to connect to the streaming server. Receive Confirmation. The streaming server responds with HTTP 101 Switching Protocols to confirm that the connection has been established. This response includes a Connection: Upgrade and a Upgrade: websocket header, as well as a hash of the key provided by the client in the Sec-WebSocket-Accept header, which prevents caching proxies from interfering with the opening handshake. HTTP / 1.1 101 Switching Protocols Upgrade : websocket Connection : Upgrade Cache-Control : private Sec-WebSocket-Accept : [hashed key] ... Create Subscription. At this point, a connection is established but no subscriptions have been created (the 'channel' is empty). In order to initiate a subscription, the client application sends a POST request to a .../subscriptions endpoint in the OpenAPI. 2 For example, a price subscription for the EURUSD FX cross (UIC 21) can be created by sending the following POST request to the trade/v1/infoprices/subscriptions/ endpoint: POST /sim/openapi/trade/v1/infoprices/subscriptions/ HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] Content-Type : application/json Accept : */* Cache-Control : no-cache Accept-Encoding : gzip, deflate Content-Length : 127 { \"Arguments\" : { \"Uics\" : \"21\" , \"AssetType\" : \"FxSpot\" } , \"ContextId\" : \"MyContextID\" , \"ReferenceId\" : \"SubscriptionReference\" } Notice that this subscription request must contain a valid access token, and identifies the WebSocket connection using the ContextId field, which must match the ID set on the initial connection request (see step 1 above). This individual subscription is identified by its ReferenceId , which is set by the client application and can be used to adjust or cancel the subscription (without disconnecting the WebSocket). Note that each individual subscription must be created with a unique ReferenceId within the context of the WebSocket connection. Receive Snapshot Data. The OpenAPI responds with HTTP 201 Created to signal that the client subscribed successfully. In the response to the subscription request, the OpenAPI sends out a snapshot of the current state of the data requested by the client application. This is the starting point of the subscription and it includes all available fields. The EURUSD price subscription for instance contains Bid/Ask prices and further details around the quote, such as Amount , which automatically defaults to 100K if it is not specified in the subscription request: { \"ContextId\" : \"MyContextID\" , \"Format\" : \"application/json\" , \"InactivityTimeout\" : 30 , \"ReferenceId\" : \"SubscriptionReference\" , \"RefreshRate\" : 1000 , \"Snapshot\" : { \"Data\" : [ { \"AssetType\" : \"FxSpot\" , \"LastUpdated\" : \"2020-02-11T09:38:20.553000Z\" , \"PriceSource\" : \"SBFX\" , \"Quote\" : { \"Amount\" : 100000 , \"Ask\" : 1.09143 , \"Bid\" : 1.09141 , \"DelayedByMinutes\" : 0 , \"ErrorCode\" : \"None\" , \"Mid\" : 1.09142 , \"PriceSource\" : \"SBFX\" , \"PriceSourceType\" : \"Firm\" , \"PriceTypeAsk\" : \"Tradable\" , \"PriceTypeBid\" : \"Tradable\" }, \"Uic\" : 21 } ] }, \"State\" : \"Active\" } Initiate Streaming. Behind the scenes, the OpenAPI automatically instructs the streaming server to start sending updates on the WebSocket connection for the newly-created subscription. These updates will be buffered if the subscription request is received before the WebSocket connection is created to ensure consistency on the client side. Receive Updates. The client now receives data messages through the WebSocket connection. These messages are sent as a stream over a series of binary WebSocket frames. Each WebSocket frame can contain multiple data messages, and data messages can be split over several WebSocket frames, in which case a continuation frame follows. The FIN bit on each frame indicates whether the contained data completes a data message (see specification here ). Frame B in the below diagram only contains part of data message 3, which should be completed using the first half of frame C. Most client libraries handle these cases automatically without requiring additional configuration. +---------------+-------------+-------------+ WebSocket frame: | A FIN=1 | B FIN=0 | C FIN=1 | +-------+-------+-------------+-----+-------+ Data message: | 1 | 2 | 3 | 4 | +-------+-------+-------------------+-------+ The binary data contained in each data message needs to be decoded by the client application (see the byte layout below). The binary data includes the RefrenceId of the subscription that it the message belongs to. The payload of the data messages is always encoded in JSON format, which contains only fields that have changed since the previous message/initial snapshot (so-called 'delta updates' ). 3 For instance, the first update message for the EURUSD price subscription created above could look like this: [ { \"LastUpdated\" : \"2020-02-11T09:38:30.972000Z\" , \"Quote\" : { \"Ask\" : 1.09148 , \"Bid\" : 1.09147 , \"Mid\" : 1.091475 }, \"Uic\" : 21 } ] Notice that the only static element in this message is the Uic field, which is required to determine which object should be updated on the client side. The updated fields are merged with the snapshot received in step 4 to create a new 'current state' of the EURUSD quote (see below). This operation is performed for every message received by the client. { \"ContextId\" : \"MyConnectionID\" , \"Format\" : \"application/json\" , \"InactivityTimeout\" : 30 , \"ReferenceId\" : \"SubscriptionReference\" , \"RefreshRate\" : 1000 , \"Snapshot\" : { \"Data\" : [ { \"AssetType\" : \"FxSpot\" , \"LastUpdated\" : \"2020-02-11T09:38:30.972000Z\" , \"PriceSource\" : \"SBFX\" , \"Quote\" : { \"Amount\" : 100000 , \"Ask\" : 1.09148 , \"Bid\" : 1.09147 , \"DelayedByMinutes\" : 0 , \"ErrorCode\" : \"None\" , \"Mid\" : 1.091475 , \"PriceSource\" : \"SBFX\" , \"PriceSourceType\" : \"Firm\" , \"PriceTypeAsk\" : \"Tradable\" , \"PriceTypeBid\" : \"Tradable\" }, \"Uic\" : 21 } ] }, \"State\" : \"Active\" } In the above overview, note that: A single WebSocket connection can serve multiple subscriptions, which are individually created and deleted when the context requires it. The WebSocket connection is exclusively used for listening to messages. Only the closing handshake requires the client app to send a message onto the connection to initiate the closing handshake. Any other messages sent by the client are ignored by the streaming server. Removing a Subscription \u00b6 When a subscription becomes obsolete, for instance when the user has 'moved on' to a different section in the app's UI that does not require certain data to continue flowing, the app should perform cleanup. This prevents unnecessary overhead on the client and server side, and ensures that the session stays within throttling limits (see below). Subscriptions are created and deleted on the same path (in our example, trade/v1/infoprices/subscriptions/ ). For deletion, the ContextID and SubscriptionReference are added as path parameters: DELETE /sim/openapi/trade/v1/infoprices/subscriptions/{ContextID}/{SubscriptionReference} HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] The OpenAPI confirms deletion by returning HTTP 202 Accepted . Decoding Data Messages \u00b6 The client application is expected to decode the byte layout of each individual message, which follows the below pattern: Byte index Size (bytes) Description Example value 0 8 Message identifier 64-bit little-endian unsigned integer uniquely identifying each message, starting at 1 for the first message. Can roll over or be reset during a session. 31 8 2 Reserved Reserved bytes for future use - to be ignored by the client application. 10 1 Reference ID size RefSize Number of bytes that make up the Reference ID of the subscription that this message belongs to. 15 11 RefSize Reference ID ASCII-encoded Reference ID corresponding to the subscription that this message belongs to or to pre-defined control messages, which always start with an underscore _ (see below). SubscriptionReference or _heartbeat 11 + RefSize 1 Payload format 8-bit unsigned integer signaling the format of the payload. Value will be 0 for data messages and control messages to signal payload is a UTF-8 encoded text string containing JSON. 0 12 + RefSize 4 Payload size PlSize 32-bit little-endian unsigned integer indicating the size of the payload contained in this message. 108 16 + RefSize PlSize Message payload UTF-8 encoded message payload, which decodes to a string representing a JSON object. This string should be deserialized into a JSON object by the client application. See update message above Disconnecting and Reconnecting \u00b6 The client can disconnect from the streaming server by sending a close frame. The server will respond with a close frame of its own, as per the WebSocket protocol . Closing a WebSocket connection automatically deletes any associated subscriptions. In case an unforeseen event causes the connection to be dropped on the transport level, the client app can reconnect to the streaming server and provide the ID of the last-seen message as a parameter. This allows for an automatic fallback to be implemented on the client side where the disruption towards the end user is as limited as possible. The streaming server caches a limited number of recent messages for this purpose. The below request provides an example of a reconnection request with the MessageId parameter set to 10: GET /sim/openapi/streamingws/connect?ContextId=[ID]&MessageId=10 HTTP / 1.1 Connection : Upgrade Upgrade : WebSocket Sec-WebSocket-Key : [auto-generated key] Sec-WebSocket-Version : 13 Authorization : Bearer [token] Host : streaming.saxobank.com Once the connection is established, the streaming server will pick up from message 11 onwards and immediately send all missed intermediate messages so the client can 'catch up'. Resetting Subscriptions \u00b6 In the event the streaming server detects failures such as message loss, it will send a _resetsubscriptions control message. This message can include a list labeled TargetReferenceIds , but it can also be empty signaling that all subscriptions need to be reset. In order to reset an existing subscription, first send a DELETE request before re-sending the POST request to prevent throttling from interfering with the reset process (see below). An example of the _resetsubscriptions control message: { \"ReferenceId\" : \"_resetsubscriptions\" , \"Timestamp\" : \"2020-02-11T15:14:22.776000Z\" , \"TargetReferenceIds\" : [ \"SubscriptionReference\" ] } Throttling \u00b6 Re-Authorizing \u00b6 Control Messages \u00b6 Keeping State on the Client Side \u00b6 Even if an application would be allowed to poll the OpenAPI on every required endpoint at a rate of > 1 request/s, streaming updates will always be faster as they are directly pushed from the server. \u21a9 Strictly speaking, the exact order of steps 1-3 is not important as the subscription request will automatically buffer updates until the corresponding WebSocket connection is created. \u21a9 Delta updates offer a significant optimization in WebSocket streaming because static/unchanged fields are never sent more than once, reducing message payload size. It does however require the client-side application to merge the update with the earlier received snapshot and intermediate messages (i.e. keep state). \u21a9","title":"WebSocket Streaming"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#introduction","text":"The OpenAPI supports streaming using a standard implementation of the WebSocket Protocol, as described in RFC6455 . Given that most of the information available to users is in constant flux (such as account balance, charts, quotes, position P&L, etc), using polling for each dynamic element that could be relevant in an application is not a viable solution. Instead, creating a single WebSocket connection and adding/removing subscriptions on-demand offers greatly reduced overhead and optimal latency. 1 In a standard use-case, an application (web, mobile, or native) creates a WebSocket connection and subscribes to the data that it requires. The subscriptions change constantly (depending on the contextual requirements) while the WebSocket connection persists. This allows for a fairly lean setup: the connection is created once (the 'channel'), and the data sent over this connection is controlled with individual POST and DELETE requests to the associated OpenAPI endpoints. The majority of endpoints support subscriptions alongside standard GET requests, which can be identified by the .../subscriptions suffix. Some examples: port/v1/netpositions/subscriptions/ , which provides real-time updates of net positions across a client's accounts. This includes details such as Exposure , ProfitLossOnTrade , and ConversionRateCurrent , which is used to convert between instrument currency and account currency in real time. chart/v1/charts/subscriptions/ , which is used to retrieve live OHLC data and (recent) historic bars, which lays the groundworks for interactive charts, indicators, strategies, etc. trade/v1/infoprices/subscriptions/ , which is used to retrieve 'informational' prices for display purposes in product overviews, chart overlays, and watchlists. This endpoint also includes functionality to retrieve in-depth price details such as daily high/low and %-change values. Depending on the specific context, an (imaginary) application might for instance follow the below sequence of OpenAPI operations while the user interacts with its UI: When a user logs on, the app creates a WebSocket connection which will be used throughout the below steps. While the UI loads, the app subscribes to port/v1/balances/subscriptions/ to show the client an overview of their current account state. This is a persistent element in the UI and the subscription will be kept alive for as long as the client is using the app. The app has a feature to draw charts, and the user selects the EURUSD Forex cross as the instrument for this chart. The app subscribes to chart/v1/charts/subscriptions/ to simultaneously create a live-updating price stream and obtain historic bars. The user switches to EURGBP in the chart. The app deletes the previous subscription as this is not longer required, and re-subscribes to chart/v1/charts/subscriptions/ to pull out data for EURGBP. The user closes the app. Any remaining subscriptions are removed and the WebSocket connection is closed. Note that all data in the above example is transferred over a single persistent 'channel' (the WebSocket connection).","title":"Introduction"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#overview-of-websocket-streaming","text":"sequenceDiagram participant C as Client Application participant S as OpenAPI <br> WebSocket Server participant O as OpenAPI <br> Endpoints C->>S: 1 - Initiate Connection S->>C: 2 - Receive Confirmation C->>O: 3 - Create Subscription O->>C: 4 - Receive Snapshot Data O->>S: 5 - Initiate Streaming loop streaming S-->>C: 6 - Receive Updates end The sequence above represents the standard flow to create a new WebSocket connection and subscribe to streaming data. It involves the following processes: Initiate Connection. The client application creates a WebSocket connection by sending a request to the OpenAPI WebSocket Server (or 'streaming server', which is located on streaming.saxobank.com ). This request, also called the 'opening handshake', follows standard WebSocket protocol and includes two additional elements: The ContextId parameter: a unique ID that identifies this connection. This ID is generated by the client application. Every API interaction that involves streaming should include this ID (see step 3 below). Example: ContextId=MyApp123abc . Make sure to create a sufficiently long random string to prevent potential clashes with other applications. The streaming server will respond with HTTP 409 Conflict if the ContextId is already used for a different connection. The Authorization header: standard authorization header containing a valid access token. Can also be sent as parameter if the client-side library does not support initiating WebSocket connections with custom headers. Example: Authorization=Bearer%20[token] . With Auth Header GET /sim/openapi/streamingws/connect?ContextId=[ID] HTTP / 1.1 Host : streaming.saxobank.com Authorization : Bearer [token] Connection : Upgrade Upgrade : WebSocket Sec-WebSocket-Key : [auto-generated key] Sec-WebSocket-Version : 13 With Auth Parameter GET /sim/openapi/streamingws/connect?ContextId=[ID]&Authorization=Bearer%20[token] HTTP / 1.1 Host : streaming.saxobank.com Connection : Upgrade Upgrade : WebSocket Sec-WebSocket-Key : [auto-generated key] Sec-WebSocket-Version : 13 Caution In many client-side libraries, the URL that is required to initiate a WebSocket connection is usually composed as: wss://host/path , replacing the http protocol prefix (which is only used on initiation - the connection is upgraded afterwards). In JavaScript for example, initiating a WebSocket connection requires the following code: let connection = new WebSocket ( \"wss://example.com/streaming?parameter=123\" ) Note The current WebSocket version supported by the OpenAPI is 13 . Client libraries using outdated versions will receive a HTTP 426 Upgrade Required response when attempting to connect to the streaming server. Receive Confirmation. The streaming server responds with HTTP 101 Switching Protocols to confirm that the connection has been established. This response includes a Connection: Upgrade and a Upgrade: websocket header, as well as a hash of the key provided by the client in the Sec-WebSocket-Accept header, which prevents caching proxies from interfering with the opening handshake. HTTP / 1.1 101 Switching Protocols Upgrade : websocket Connection : Upgrade Cache-Control : private Sec-WebSocket-Accept : [hashed key] ... Create Subscription. At this point, a connection is established but no subscriptions have been created (the 'channel' is empty). In order to initiate a subscription, the client application sends a POST request to a .../subscriptions endpoint in the OpenAPI. 2 For example, a price subscription for the EURUSD FX cross (UIC 21) can be created by sending the following POST request to the trade/v1/infoprices/subscriptions/ endpoint: POST /sim/openapi/trade/v1/infoprices/subscriptions/ HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] Content-Type : application/json Accept : */* Cache-Control : no-cache Accept-Encoding : gzip, deflate Content-Length : 127 { \"Arguments\" : { \"Uics\" : \"21\" , \"AssetType\" : \"FxSpot\" } , \"ContextId\" : \"MyContextID\" , \"ReferenceId\" : \"SubscriptionReference\" } Notice that this subscription request must contain a valid access token, and identifies the WebSocket connection using the ContextId field, which must match the ID set on the initial connection request (see step 1 above). This individual subscription is identified by its ReferenceId , which is set by the client application and can be used to adjust or cancel the subscription (without disconnecting the WebSocket). Note that each individual subscription must be created with a unique ReferenceId within the context of the WebSocket connection. Receive Snapshot Data. The OpenAPI responds with HTTP 201 Created to signal that the client subscribed successfully. In the response to the subscription request, the OpenAPI sends out a snapshot of the current state of the data requested by the client application. This is the starting point of the subscription and it includes all available fields. The EURUSD price subscription for instance contains Bid/Ask prices and further details around the quote, such as Amount , which automatically defaults to 100K if it is not specified in the subscription request: { \"ContextId\" : \"MyContextID\" , \"Format\" : \"application/json\" , \"InactivityTimeout\" : 30 , \"ReferenceId\" : \"SubscriptionReference\" , \"RefreshRate\" : 1000 , \"Snapshot\" : { \"Data\" : [ { \"AssetType\" : \"FxSpot\" , \"LastUpdated\" : \"2020-02-11T09:38:20.553000Z\" , \"PriceSource\" : \"SBFX\" , \"Quote\" : { \"Amount\" : 100000 , \"Ask\" : 1.09143 , \"Bid\" : 1.09141 , \"DelayedByMinutes\" : 0 , \"ErrorCode\" : \"None\" , \"Mid\" : 1.09142 , \"PriceSource\" : \"SBFX\" , \"PriceSourceType\" : \"Firm\" , \"PriceTypeAsk\" : \"Tradable\" , \"PriceTypeBid\" : \"Tradable\" }, \"Uic\" : 21 } ] }, \"State\" : \"Active\" } Initiate Streaming. Behind the scenes, the OpenAPI automatically instructs the streaming server to start sending updates on the WebSocket connection for the newly-created subscription. These updates will be buffered if the subscription request is received before the WebSocket connection is created to ensure consistency on the client side. Receive Updates. The client now receives data messages through the WebSocket connection. These messages are sent as a stream over a series of binary WebSocket frames. Each WebSocket frame can contain multiple data messages, and data messages can be split over several WebSocket frames, in which case a continuation frame follows. The FIN bit on each frame indicates whether the contained data completes a data message (see specification here ). Frame B in the below diagram only contains part of data message 3, which should be completed using the first half of frame C. Most client libraries handle these cases automatically without requiring additional configuration. +---------------+-------------+-------------+ WebSocket frame: | A FIN=1 | B FIN=0 | C FIN=1 | +-------+-------+-------------+-----+-------+ Data message: | 1 | 2 | 3 | 4 | +-------+-------+-------------------+-------+ The binary data contained in each data message needs to be decoded by the client application (see the byte layout below). The binary data includes the RefrenceId of the subscription that it the message belongs to. The payload of the data messages is always encoded in JSON format, which contains only fields that have changed since the previous message/initial snapshot (so-called 'delta updates' ). 3 For instance, the first update message for the EURUSD price subscription created above could look like this: [ { \"LastUpdated\" : \"2020-02-11T09:38:30.972000Z\" , \"Quote\" : { \"Ask\" : 1.09148 , \"Bid\" : 1.09147 , \"Mid\" : 1.091475 }, \"Uic\" : 21 } ] Notice that the only static element in this message is the Uic field, which is required to determine which object should be updated on the client side. The updated fields are merged with the snapshot received in step 4 to create a new 'current state' of the EURUSD quote (see below). This operation is performed for every message received by the client. { \"ContextId\" : \"MyConnectionID\" , \"Format\" : \"application/json\" , \"InactivityTimeout\" : 30 , \"ReferenceId\" : \"SubscriptionReference\" , \"RefreshRate\" : 1000 , \"Snapshot\" : { \"Data\" : [ { \"AssetType\" : \"FxSpot\" , \"LastUpdated\" : \"2020-02-11T09:38:30.972000Z\" , \"PriceSource\" : \"SBFX\" , \"Quote\" : { \"Amount\" : 100000 , \"Ask\" : 1.09148 , \"Bid\" : 1.09147 , \"DelayedByMinutes\" : 0 , \"ErrorCode\" : \"None\" , \"Mid\" : 1.091475 , \"PriceSource\" : \"SBFX\" , \"PriceSourceType\" : \"Firm\" , \"PriceTypeAsk\" : \"Tradable\" , \"PriceTypeBid\" : \"Tradable\" }, \"Uic\" : 21 } ] }, \"State\" : \"Active\" } In the above overview, note that: A single WebSocket connection can serve multiple subscriptions, which are individually created and deleted when the context requires it. The WebSocket connection is exclusively used for listening to messages. Only the closing handshake requires the client app to send a message onto the connection to initiate the closing handshake. Any other messages sent by the client are ignored by the streaming server.","title":"Overview of WebSocket Streaming"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#removing-a-subscription","text":"When a subscription becomes obsolete, for instance when the user has 'moved on' to a different section in the app's UI that does not require certain data to continue flowing, the app should perform cleanup. This prevents unnecessary overhead on the client and server side, and ensures that the session stays within throttling limits (see below). Subscriptions are created and deleted on the same path (in our example, trade/v1/infoprices/subscriptions/ ). For deletion, the ContextID and SubscriptionReference are added as path parameters: DELETE /sim/openapi/trade/v1/infoprices/subscriptions/{ContextID}/{SubscriptionReference} HTTP / 1.1 Host : gateway.saxobank.com Authorization : Bearer [token] The OpenAPI confirms deletion by returning HTTP 202 Accepted .","title":"Removing a Subscription"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#decoding-data-messages","text":"The client application is expected to decode the byte layout of each individual message, which follows the below pattern: Byte index Size (bytes) Description Example value 0 8 Message identifier 64-bit little-endian unsigned integer uniquely identifying each message, starting at 1 for the first message. Can roll over or be reset during a session. 31 8 2 Reserved Reserved bytes for future use - to be ignored by the client application. 10 1 Reference ID size RefSize Number of bytes that make up the Reference ID of the subscription that this message belongs to. 15 11 RefSize Reference ID ASCII-encoded Reference ID corresponding to the subscription that this message belongs to or to pre-defined control messages, which always start with an underscore _ (see below). SubscriptionReference or _heartbeat 11 + RefSize 1 Payload format 8-bit unsigned integer signaling the format of the payload. Value will be 0 for data messages and control messages to signal payload is a UTF-8 encoded text string containing JSON. 0 12 + RefSize 4 Payload size PlSize 32-bit little-endian unsigned integer indicating the size of the payload contained in this message. 108 16 + RefSize PlSize Message payload UTF-8 encoded message payload, which decodes to a string representing a JSON object. This string should be deserialized into a JSON object by the client application. See update message above","title":"Decoding Data Messages"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#disconnecting-and-reconnecting","text":"The client can disconnect from the streaming server by sending a close frame. The server will respond with a close frame of its own, as per the WebSocket protocol . Closing a WebSocket connection automatically deletes any associated subscriptions. In case an unforeseen event causes the connection to be dropped on the transport level, the client app can reconnect to the streaming server and provide the ID of the last-seen message as a parameter. This allows for an automatic fallback to be implemented on the client side where the disruption towards the end user is as limited as possible. The streaming server caches a limited number of recent messages for this purpose. The below request provides an example of a reconnection request with the MessageId parameter set to 10: GET /sim/openapi/streamingws/connect?ContextId=[ID]&MessageId=10 HTTP / 1.1 Connection : Upgrade Upgrade : WebSocket Sec-WebSocket-Key : [auto-generated key] Sec-WebSocket-Version : 13 Authorization : Bearer [token] Host : streaming.saxobank.com Once the connection is established, the streaming server will pick up from message 11 onwards and immediately send all missed intermediate messages so the client can 'catch up'.","title":"Disconnecting and Reconnecting"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#resetting-subscriptions","text":"In the event the streaming server detects failures such as message loss, it will send a _resetsubscriptions control message. This message can include a list labeled TargetReferenceIds , but it can also be empty signaling that all subscriptions need to be reset. In order to reset an existing subscription, first send a DELETE request before re-sending the POST request to prevent throttling from interfering with the reset process (see below). An example of the _resetsubscriptions control message: { \"ReferenceId\" : \"_resetsubscriptions\" , \"Timestamp\" : \"2020-02-11T15:14:22.776000Z\" , \"TargetReferenceIds\" : [ \"SubscriptionReference\" ] }","title":"Resetting Subscriptions"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#throttling","text":"","title":"Throttling"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#re-authorizing","text":"","title":"Re-Authorizing"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#control-messages","text":"","title":"Control Messages"},{"location":"basics/fundamental-programming-concepts/websocket-streaming/#keeping-state-on-the-client-side","text":"Even if an application would be allowed to poll the OpenAPI on every required endpoint at a rate of > 1 request/s, streaming updates will always be faster as they are directly pushed from the server. \u21a9 Strictly speaking, the exact order of steps 1-3 is not important as the subscription request will automatically buffer updates until the corresponding WebSocket connection is created. \u21a9 Delta updates offer a significant optimization in WebSocket streaming because static/unchanged fields are never sent more than once, reducing message payload size. It does however require the client-side application to merge the update with the earlier received snapshot and intermediate messages (i.e. keep state). \u21a9","title":"Keeping State on the Client Side"},{"location":"basics/fundamental-programming-concepts/order-placement/","text":"Orders are placed from the client application by sending a POST request to the OpenAPI endpoint: trade/v2/orders . graph LR C(\"Client Application\") -- POST --> O(\"trade/v2/orders\") style C fill:LightGreen style O fill:SkyBlue The body of the POST requests contains at minimum the following data: { \"AccountKey\" : \"[account key]\" , \"Amount\" : \"\" , \"AssetType\" : \"\" , \"BuySell\" : \"\" , \"OrderType\" : \"\" , \"Uic\" : 0 }","title":"Introduction"},{"location":"basics/fundamental-programming-concepts/order-placement/stock/","text":"Introduction \u00b6 This article demonstrates how to place order for Stock instruments. The below interactive order placement tool is generated using the sample in the repository located here: view standalone code sample on GitHub Follow these steps to run the sample: Grab a 24-hour token from Saxo's developer portal and plug it into the input box. This will allow the JS sample to connect to the OpenAPI. Pick your instrument and order type. Adjust the parameters of your order by directly changing the JSON object in the window below. Note The AccountKey is automatically added to the JSON request by the sample using the /port/v1/accounts/me/ endpoint. Sample: \u00b6 Token (from developer.saxobank.com/openapi/token ): Asset type: Stock StockOption Order type: Limit Market Order object: { \"AccountKey\": \"(added on first request)\", \"OrderType\": \"Limit\", \"AssetType\": \"Stock\", \"BuySell\": \"Buy\", \"Amount\": 100, \"Uic\": 112809, \"OrderDuration\": { \"DurationType\": \"DayOrder\" }, \"ManualOrder\": false, \"OrderPrice\": 70 } /*jslint this: true, browser: true, for: true, long: true */ /*global console */ var accountKey = \"\"; /** * Shared function to display an unsuccessful response. * @param {Object} errorObject The complete error object. * @return {void} */ function processError(errorObject) { var textToDisplay = \"Error with status \" + errorObject.status + \" \" + errorObject.statusText; console.error(textToDisplay + \" \" + errorObject.url); // Some errors have a JSON-response, containing explanation of what went wrong. errorObject.json().then(function (errorObjectJson) { if (errorObjectJson.hasOwnProperty(\"ErrorInfo\")) { // Order error object is wrapped in ErrorInfo errorObjectJson = errorObjectJson.ErrorInfo; } // Order preview error object not.. if (errorObjectJson.hasOwnProperty(\"ErrorCode\")) { textToDisplay += \" - \" + errorObjectJson.ErrorCode + \" (\" + errorObjectJson.Message + \")\"; } document.getElementById(\"idResponse\").innerText = textToDisplay; }).catch(function (ignore) { // Typically 401 (Unauthorized) has an empty response, this generates a SyntaxError. document.getElementById(\"idResponse\").innerText = textToDisplay; }); } /** * Show a function and run it. * @param {Function} functionToRun The function in scope. * @return {void} */ function run(functionToRun) { // Display source used for demonstration: document.getElementById(\"idJavaScript\").innerText = functionToRun.toString(); if (document.getElementById(\"idBearerToken\").value === \"\") { document.getElementById(\"idResponse\").innerText = \"Bearer token is required to do requests.\"; } else { if (accountKey === \"\") { // Retrieve the account key first fetch( \"https://gateway.saxobank.com/sim/openapi/port/v1/accounts/me\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"GET\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { accountKey = responseJson.Data[0].AccountKey; // Just get the first account console.log(\"Using accountKey: \" + accountKey); functionToRun(); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } else { functionToRun(); } } } (function () { /** * Read a cookie. * @param {string} key Name of the cookie. * @return {string} Value. */ function getCookie(key) { var name = key + \"=\"; var decodedCookie = decodeURIComponent(document.cookie); var cookieArray = decodedCookie.split(\";\"); var i; var c; for (i = 0; i < cookieArray.length; i += 1) { c = cookieArray[i]; while (c.charAt(0) === \" \") { c = c.substring(1); } if (c.indexOf(name) === 0) { return c.substring(name.length, c.length); } } return \"\"; } /** * Insert a cookie. In order to delete it, make value empty. * @param {string} key Name of the cookie. * @param {string} value Value to store. * @return {void} */ function setCookie(key, value) { var expires = new Date(); // Cookie is valid for 360 days. expires.setTime(expires.getTime() + 360 * 24 * 60 * 60 * 1000); document.cookie = key + \"=\" + value + \";expires=\" + expires.toUTCString(); } // Show most recent used token: var previouslyUsedToken = getCookie(\"saxotoken\"); if (previouslyUsedToken !== \"\") { document.getElementById(\"idBearerToken\").value = previouslyUsedToken; } window.addEventListener(\"beforeunload\", function () { var token = document.getElementById(\"idBearerToken\").value; if (token.length > 10) { // Save the token so it can be reused: setCookie(\"saxotoken\", token); } }); }()); /*jslint this: true, browser: true, for: true, long: true */ /*global window console accountKey run processError */ var orderSequenceNumber = 1; var lastOrderId = 0; /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function getConditions() { var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; fetch( \"https://gateway.saxobank.com/sim/openapi/ref/v1/instruments/details?Uics=\" + newOrderObject.Uic + \"&AssetTypes=\" + newOrderObject.AssetType + \"&AccountKey=\" + newOrderObject.AccountKey + \"&FieldGroups=OrderSetting\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"GET\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Test for SupportedOrderTypes and TickSizeScheme document.getElementById(\"idResponse\").innerText = \"Successful request with response: \\n\" + JSON.stringify(responseJson.Data); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of getting the costs of this order. * @return {void} */ function getOrderCosts() { // https://www.developer.saxo/openapi/learn/mifid-2-cost-reporting throw \"Order costs are not implemented yet.\"; } /** * This is an example of getting the Key Information Document of this instrument. * @return {void} */ function getKid() { throw \"KID is not implemented yet.\"; } /** * This is an example of an order validation. * @return {void} */ function preCheckNewOrder() { // Bug: Preview doesnt check for limit outside market hours var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders/precheck\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"body\": JSON.stringify(newOrderObject), \"method\": \"POST\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have PreCheckResult property being \"Ok\" document.getElementById(\"idResponse\").innerText = \"Successful request with response: \\n\" + JSON.stringify(responseJson); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of placing a single leg order. * @return {void} */ function placeNewOrder() { var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", // https://www.developer.saxo/openapi/learn/rate-limiting \"X-Request-ID\": \"Reference_Insert_\" + orderSequenceNumber, // Warning! Prevent error 409 (Conflict) from identical orders within 15 seconds \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"body\": JSON.stringify(newOrderObject), \"method\": \"POST\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have an OrderId document.getElementById(\"idResponse\").innerText = \"Successful request with sequence \" + response.headers.get(\"X-Request-ID\") + \" and response: \\n\" + JSON.stringify(responseJson); orderSequenceNumber += 1; lastOrderId = responseJson.OrderId; }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of updating a single leg order. * @return {void} */ function modifyLastOrder() { var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; newOrderObject.OrderId = lastOrderId; newOrderObject.Amout = newOrderObject.Amount * 2; fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"X-Request-ID\": \"Reference_Update_\" + orderSequenceNumber, // Warning! Prevent error 409 (Conflict) from identical orders within 15 seconds \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"body\": JSON.stringify(newOrderObject), \"method\": \"PATCH\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have an OrderId document.getElementById(\"idResponse\").innerText = \"Successful request with sequence \" + response.headers.get(\"X-Request-ID\") + \" and response: \\n\" + JSON.stringify(responseJson); orderSequenceNumber += 1; }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of removing an order from the book. * @return {void} */ function cancelLastOrder() { fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders/\" + lastOrderId + \"?AccountKey=\" + accountKey, { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"DELETE\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have an OrderId document.getElementById(\"idResponse\").innerText = \"Successful request with response: \\n\" + JSON.stringify(responseJson); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } document.getElementById(\"idBtnGetConditions\").addEventListener(\"click\", function () { run(getConditions); }); document.getElementById(\"idBtnPreCheckOrder\").addEventListener(\"click\", function () { run(preCheckNewOrder); }); document.getElementById(\"idBtnGetOrderCosts\").addEventListener(\"click\", function () { run(getOrderCosts); }); document.getElementById(\"idBtnGetKid\").addEventListener(\"click\", function () { run(getKid); }); document.getElementById(\"idBtnPlaceNewOrder\").addEventListener(\"click\", function () { run(placeNewOrder); }); document.getElementById(\"idBtnModifyLastOrder\").addEventListener(\"click\", function () { run(modifyLastOrder); }); document.getElementById(\"idBtnCancelLastOrder\").addEventListener(\"click\", function () { run(cancelLastOrder); });","title":"Stock"},{"location":"basics/fundamental-programming-concepts/order-placement/stock/#introduction","text":"This article demonstrates how to place order for Stock instruments. The below interactive order placement tool is generated using the sample in the repository located here: view standalone code sample on GitHub Follow these steps to run the sample: Grab a 24-hour token from Saxo's developer portal and plug it into the input box. This will allow the JS sample to connect to the OpenAPI. Pick your instrument and order type. Adjust the parameters of your order by directly changing the JSON object in the window below. Note The AccountKey is automatically added to the JSON request by the sample using the /port/v1/accounts/me/ endpoint.","title":"Introduction"},{"location":"basics/fundamental-programming-concepts/order-placement/stock/#sample","text":"Token (from developer.saxobank.com/openapi/token ): Asset type: Stock StockOption Order type: Limit Market Order object: { \"AccountKey\": \"(added on first request)\", \"OrderType\": \"Limit\", \"AssetType\": \"Stock\", \"BuySell\": \"Buy\", \"Amount\": 100, \"Uic\": 112809, \"OrderDuration\": { \"DurationType\": \"DayOrder\" }, \"ManualOrder\": false, \"OrderPrice\": 70 } /*jslint this: true, browser: true, for: true, long: true */ /*global console */ var accountKey = \"\"; /** * Shared function to display an unsuccessful response. * @param {Object} errorObject The complete error object. * @return {void} */ function processError(errorObject) { var textToDisplay = \"Error with status \" + errorObject.status + \" \" + errorObject.statusText; console.error(textToDisplay + \" \" + errorObject.url); // Some errors have a JSON-response, containing explanation of what went wrong. errorObject.json().then(function (errorObjectJson) { if (errorObjectJson.hasOwnProperty(\"ErrorInfo\")) { // Order error object is wrapped in ErrorInfo errorObjectJson = errorObjectJson.ErrorInfo; } // Order preview error object not.. if (errorObjectJson.hasOwnProperty(\"ErrorCode\")) { textToDisplay += \" - \" + errorObjectJson.ErrorCode + \" (\" + errorObjectJson.Message + \")\"; } document.getElementById(\"idResponse\").innerText = textToDisplay; }).catch(function (ignore) { // Typically 401 (Unauthorized) has an empty response, this generates a SyntaxError. document.getElementById(\"idResponse\").innerText = textToDisplay; }); } /** * Show a function and run it. * @param {Function} functionToRun The function in scope. * @return {void} */ function run(functionToRun) { // Display source used for demonstration: document.getElementById(\"idJavaScript\").innerText = functionToRun.toString(); if (document.getElementById(\"idBearerToken\").value === \"\") { document.getElementById(\"idResponse\").innerText = \"Bearer token is required to do requests.\"; } else { if (accountKey === \"\") { // Retrieve the account key first fetch( \"https://gateway.saxobank.com/sim/openapi/port/v1/accounts/me\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"GET\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { accountKey = responseJson.Data[0].AccountKey; // Just get the first account console.log(\"Using accountKey: \" + accountKey); functionToRun(); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } else { functionToRun(); } } } (function () { /** * Read a cookie. * @param {string} key Name of the cookie. * @return {string} Value. */ function getCookie(key) { var name = key + \"=\"; var decodedCookie = decodeURIComponent(document.cookie); var cookieArray = decodedCookie.split(\";\"); var i; var c; for (i = 0; i < cookieArray.length; i += 1) { c = cookieArray[i]; while (c.charAt(0) === \" \") { c = c.substring(1); } if (c.indexOf(name) === 0) { return c.substring(name.length, c.length); } } return \"\"; } /** * Insert a cookie. In order to delete it, make value empty. * @param {string} key Name of the cookie. * @param {string} value Value to store. * @return {void} */ function setCookie(key, value) { var expires = new Date(); // Cookie is valid for 360 days. expires.setTime(expires.getTime() + 360 * 24 * 60 * 60 * 1000); document.cookie = key + \"=\" + value + \";expires=\" + expires.toUTCString(); } // Show most recent used token: var previouslyUsedToken = getCookie(\"saxotoken\"); if (previouslyUsedToken !== \"\") { document.getElementById(\"idBearerToken\").value = previouslyUsedToken; } window.addEventListener(\"beforeunload\", function () { var token = document.getElementById(\"idBearerToken\").value; if (token.length > 10) { // Save the token so it can be reused: setCookie(\"saxotoken\", token); } }); }()); /*jslint this: true, browser: true, for: true, long: true */ /*global window console accountKey run processError */ var orderSequenceNumber = 1; var lastOrderId = 0; /** * This is an example of getting the trading settings of an instrument. * @return {void} */ function getConditions() { var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; fetch( \"https://gateway.saxobank.com/sim/openapi/ref/v1/instruments/details?Uics=\" + newOrderObject.Uic + \"&AssetTypes=\" + newOrderObject.AssetType + \"&AccountKey=\" + newOrderObject.AccountKey + \"&FieldGroups=OrderSetting\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"GET\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Test for SupportedOrderTypes and TickSizeScheme document.getElementById(\"idResponse\").innerText = \"Successful request with response: \\n\" + JSON.stringify(responseJson.Data); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of getting the costs of this order. * @return {void} */ function getOrderCosts() { // https://www.developer.saxo/openapi/learn/mifid-2-cost-reporting throw \"Order costs are not implemented yet.\"; } /** * This is an example of getting the Key Information Document of this instrument. * @return {void} */ function getKid() { throw \"KID is not implemented yet.\"; } /** * This is an example of an order validation. * @return {void} */ function preCheckNewOrder() { // Bug: Preview doesnt check for limit outside market hours var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders/precheck\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"body\": JSON.stringify(newOrderObject), \"method\": \"POST\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have PreCheckResult property being \"Ok\" document.getElementById(\"idResponse\").innerText = \"Successful request with response: \\n\" + JSON.stringify(responseJson); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of placing a single leg order. * @return {void} */ function placeNewOrder() { var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", // https://www.developer.saxo/openapi/learn/rate-limiting \"X-Request-ID\": \"Reference_Insert_\" + orderSequenceNumber, // Warning! Prevent error 409 (Conflict) from identical orders within 15 seconds \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"body\": JSON.stringify(newOrderObject), \"method\": \"POST\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have an OrderId document.getElementById(\"idResponse\").innerText = \"Successful request with sequence \" + response.headers.get(\"X-Request-ID\") + \" and response: \\n\" + JSON.stringify(responseJson); orderSequenceNumber += 1; lastOrderId = responseJson.OrderId; }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of updating a single leg order. * @return {void} */ function modifyLastOrder() { var newOrderObject = JSON.parse(document.getElementById(\"idNewOrderObject\").value); newOrderObject.AccountKey = accountKey; newOrderObject.OrderId = lastOrderId; newOrderObject.Amout = newOrderObject.Amount * 2; fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders\", { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"X-Request-ID\": \"Reference_Update_\" + orderSequenceNumber, // Warning! Prevent error 409 (Conflict) from identical orders within 15 seconds \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"body\": JSON.stringify(newOrderObject), \"method\": \"PATCH\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have an OrderId document.getElementById(\"idResponse\").innerText = \"Successful request with sequence \" + response.headers.get(\"X-Request-ID\") + \" and response: \\n\" + JSON.stringify(responseJson); orderSequenceNumber += 1; }); } else { processError(response); } }).catch(function (error) { processError(error); }); } /** * This is an example of removing an order from the book. * @return {void} */ function cancelLastOrder() { fetch( \"https://gateway.saxobank.com/sim/openapi/trade/v2/orders/\" + lastOrderId + \"?AccountKey=\" + accountKey, { \"headers\": { \"Content-Type\": \"application/json; charset=utf-8\", \"Authorization\": \"Bearer \" + document.getElementById(\"idBearerToken\").value }, \"method\": \"DELETE\" } ).then(function (response) { if (response.ok) { response.json().then(function (responseJson) { // Response must have an OrderId document.getElementById(\"idResponse\").innerText = \"Successful request with response: \\n\" + JSON.stringify(responseJson); }); } else { processError(response); } }).catch(function (error) { processError(error); }); } document.getElementById(\"idBtnGetConditions\").addEventListener(\"click\", function () { run(getConditions); }); document.getElementById(\"idBtnPreCheckOrder\").addEventListener(\"click\", function () { run(preCheckNewOrder); }); document.getElementById(\"idBtnGetOrderCosts\").addEventListener(\"click\", function () { run(getOrderCosts); }); document.getElementById(\"idBtnGetKid\").addEventListener(\"click\", function () { run(getKid); }); document.getElementById(\"idBtnPlaceNewOrder\").addEventListener(\"click\", function () { run(placeNewOrder); }); document.getElementById(\"idBtnModifyLastOrder\").addEventListener(\"click\", function () { run(modifyLastOrder); }); document.getElementById(\"idBtnCancelLastOrder\").addEventListener(\"click\", function () { run(cancelLastOrder); });","title":"Sample:"},{"location":"individual/","text":"","title":"Introduction"},{"location":"institutional/","text":"","title":"Introduction"},{"location":"third-party/","text":"","title":"Introduction"},{"location":"updates/","text":"This section covers release notes and announcements around upcoming changes within the OpenAPI.","title":"Overview"},{"location":"updates/changes/","text":"something","title":"Planned Changes"},{"location":"updates/release-notes/","text":"","title":"Guide"},{"location":"updates/release-notes/2019-09-03/","text":"","title":"2019-09-03"},{"location":"updates/release-notes/2019-11-25/","text":"","title":"2019-11-25"},{"location":"updates/release-notes/2019-12-13/","text":"","title":"2019-12-13 - Breaking"}]}